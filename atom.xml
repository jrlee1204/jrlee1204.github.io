<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jrlee&#39;s blog</title>
  
  <description>feedId:68946518944817152+userId:68844453982752768</description>
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-15T09:27:38.255Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>jrlee</name>
    
  </author>
  <follow_challenge>
    <feedId>68946518944817152</feedId>
    <userId>68844453982752768</userId>
  </follow_challenge>
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言入门08——Map</title>
    <link href="http://example.com/p/a4fd9aa6.html"/>
    <id>http://example.com/p/a4fd9aa6.html</id>
    <published>2024-09-28T04:23:13.000Z</published>
    <updated>2024-10-15T09:27:38.255Z</updated>
    
    <content type="html"><![CDATA[<p>map是一种键值对形式的数据结构，一个键对应一个值，可以通过键快速检索出其对应的value值，在map中key的值是唯一的，value的值不唯一，并且map中保存的数据是无序的。</p><h1 id="Map声明"><a href="#Map声明" class="headerlink" title="Map声明"></a>Map声明</h1><p>声明Map可以使用map关键字进行声明，同时也可以通过make函数进行声明，仅仅通过map关键字声明的map为nil map，没有初始化的情况无法使用，如果直接往map里面赋值会发生panic，使用make函数声明后map才会在分配内存空间，且可以正常使用。</p><p>语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明变量，默认 map 是 nil</span><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">map</span>名 <span class="hljs-keyword">map</span>[键类型]值类型<br><br><span class="hljs-comment">// 使用 make 函数</span><br><span class="hljs-keyword">map</span>名 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[键类型]值类型)<br></code></pre></td></tr></table></figure><p>基本使用代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 当前声明的m为nil map，无法直接使用</span><br><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><span class="hljs-comment">// 使用make初始化之后可正常使用</span><br>m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><span class="hljs-comment">// 朝m里面放一个键为one，值为1的键值对数据</span><br>m[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-number">1</span><br>m[<span class="hljs-string">&quot;two&quot;</span>] = <span class="hljs-number">2</span><br><span class="hljs-comment">// 取出键为one对应的值</span><br>fmt.Println(m[<span class="hljs-string">&quot;one&quot;</span>])<br>fmt.Println(m[<span class="hljs-string">&quot;two&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/a4fd9aa6/1.png" class="" title="运行结果"><p><strong>map中的键是唯一的，</strong>如果在map中已经存放了一个key对应的value，再次存放一样的key进去就会覆盖之前的value。</p><p>在使用map关键字声明一个map时，由于是nil map，所以直接使用会报panic，但是可以在声明时直接初始化赋值，这样使用时就不会导致panic，申明初始化方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span> : <span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span> : <span class="hljs-number">2</span>, <span class="hljs-string">&quot;three&quot;</span> : <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h1 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h1><p>map可以使用<code>for range</code>循环进行遍历，遍历是会得到map中的key集合，然后使用key即可获取到map的value。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span> : <span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span> : <span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> m &#123;<br>fmt.Printf(<span class="hljs-string">&quot;键%s对应的值为%d \n&quot;</span>, key, m[key])<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/a4fd9aa6/2.png" class="" title="运行结果"><h1 id="查看元素是否存在"><a href="#查看元素是否存在" class="headerlink" title="查看元素是否存在"></a>查看元素是否存在</h1><p>使用map名加中括号的方式获取一个key对应的value，如果当key不存在时，获取到的就是map声明时对应类型的默认值，例如<code>var m map[string]int</code>，如果这时候获取一个不存在的key，返回的就是0，那么我们要如何才能知道返回的0是代表不存在这个key还是这个key对应的value本来就是0呢？</p><p>其实对于这个问题的解决方法很简单，在map通过中括号取值时，不只是返回一个值，还会返回一个bool类型，这个类型就代表了当前需要查找的key是否存在。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;zero&quot;</span> : <span class="hljs-number">0</span>, <span class="hljs-string">&quot;one&quot;</span> : <span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span> : <span class="hljs-number">2</span>&#125;<br>value, ok := m[<span class="hljs-string">&quot;zero&quot;</span>]<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;zero存在，value：&quot;</span>, value)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;zero不存在，value：&quot;</span>, value)<br>&#125;<br>value, ok = m[<span class="hljs-string">&quot;three&quot;</span>]<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;three存在，value：&quot;</span>, value)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;three不存在，value：&quot;</span>, value)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，m中有key为zero对应的值为0，所以直接通过<code>m[&quot;zero&quot;]</code>取值，获取到的ok为true，且value&#x3D;0，但是在使用<code>m[&quot;three&quot;]</code>取值时，由于m中没有three这个key，所以获取到的ok为false，value同样也是0。</p><p>运行结果：</p><img src="/p/a4fd9aa6/3.png" class="" title="运行结果"><h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><p>在使用map时还可以通过delete函数删除map中的元素，使用delete函数时需要指定两个参数，第一个参数为需要操作的map，第二个参数为需要删除的key。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;zero&quot;</span> : <span class="hljs-number">0</span>, <span class="hljs-string">&quot;one&quot;</span> : <span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span> : <span class="hljs-number">2</span>&#125;<br>    <span class="hljs-comment">// 删除m中key为two的元素</span><br><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;two&quot;</span>)<br>value, ok := m[<span class="hljs-string">&quot;two&quot;</span>]<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(value)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;two不存在&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于删除了two这个key，所以再次通过这个key取值的时候就会提示<code>two不存在</code></p><p>运行结果：</p><img src="/p/a4fd9aa6/4.png" class="" title="运行结果">]]></content>
    
    
    <summary type="html">map是一种键值对形式的数据结构，一个键对应一个值，可以通过键快速检索出其对应的value值，在map中key的值是唯一的，value的值不唯一，并且map中保存的数据是无序的。</summary>
    
    
    
    <category term="Go语言入门" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Golang入门" scheme="http://example.com/tags/Golang%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Go语言入门07——切片</title>
    <link href="http://example.com/p/b36c2af7.html"/>
    <id>http://example.com/p/b36c2af7.html</id>
    <published>2024-09-28T04:17:25.000Z</published>
    <updated>2024-10-15T09:27:38.249Z</updated>
    
    <content type="html"><![CDATA[<p>在go语言中，切片是对数组的抽象，数组在声明时指定了长度之后就不可再进行改变，在特定场景下数组就不适用，所以就有了切片类型，切片就是“动态数组”，和数组相比，切片的长度是不固定的，可以在切片后面追加元素，长度自动扩容。</p><h2 id="切片定义"><a href="#切片定义" class="headerlink" title="切片定义"></a>切片定义</h2><p>定义切片和定义数组很像，区别就是定义一个切片不需要指定长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> 切片名 []类型<br></code></pre></td></tr></table></figure><p>切片还可以使用make函数定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>([]T, length, capacity)<br></code></pre></td></tr></table></figure><p>make函数有三个参数：</p><ol><li>第一个参数为切片类型，可以是<code>[]int，[]string，[]float32</code>等。</li><li>第二个参数为切片初始长度。</li><li>第三个为切片容量，该参数为可选参数。</li></ol><h2 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h2><p>一个切片在初始化之前为空切片（nil），长度为0，可以在声明切片时直接初始化切片，如下表示声明一个int切片，初始化值为{1, 2, 3}</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s :=[] <span class="hljs-type">int</span> &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;<br></code></pre></td></tr></table></figure><p>初始化为数组的引用，假设有一个数组arr，在初始化为数组的引用时，通过开始索引和结束索引控制初始化的切片大小和切片内元素个数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := arr[startIndex:endIndex]<span class="hljs-comment">// 从 startIndex 到 endIndex - 1 初始化为一个切片</span><br>s := arr[startIndex:]<span class="hljs-comment">// 从 startIndex 到 数组结尾 初始化为一个切片</span><br>s := arr[:endIndex]<span class="hljs-comment">// 从 数组开始 到 endIndex - 1 初始化为一个切片</span><br>s := arr[:]<span class="hljs-comment">// 从 数组开始 到 数组结尾 初始化为一个切片（整个数组）</span><br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>arr := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>s1 := arr[:]<br>s2 := arr[<span class="hljs-number">2</span>:]<br>s3 := arr[:<span class="hljs-number">3</span>]<br>s4 := arr[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br>fmt.Println(s1)<br>fmt.Println(s2)<br>fmt.Println(s3)<br>fmt.Println(s4)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/b36c2af7/1.png" class="" title="运行结果"><h2 id="append和copy"><a href="#append和copy" class="headerlink" title="append和copy"></a>append和copy</h2><p>append表示在一个切片的末尾追加元素。</p><p>copy表示复制一个切片里面的元素到另一个切片。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;切片s：&quot;</span>,s)<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">4</span>)<span class="hljs-comment">// 添加一个元素4到切片s中</span><br>fmt.Println(<span class="hljs-string">&quot;切片s：&quot;</span>,s)<br>s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">copy</span>(s1, s)<span class="hljs-comment">// 将切片s的内容拷贝到切片s1中</span><br>fmt.Println(<span class="hljs-string">&quot;切片s1：&quot;</span>,s1)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/b36c2af7/2.png" class="" title="运行结果"><h2 id="切片截取"><a href="#切片截取" class="headerlink" title="切片截取"></a>切片截取</h2><p>切片截取使用中括号<code>[]</code>，通过指定需要截取的开始索引和结束索引。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;完整切片：&quot;</span>, s)<br>fmt.Println(<span class="hljs-string">&quot;s[1:3]：&quot;</span>, s[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])<span class="hljs-comment">// 截取索引1（包含）到索引3（不包含）</span><br>fmt.Println(<span class="hljs-string">&quot;s[:4]：&quot;</span>, s[:<span class="hljs-number">4</span>])<span class="hljs-comment">// 默认开始索引为0</span><br>fmt.Println(<span class="hljs-string">&quot;s[2:]：&quot;</span>, s[<span class="hljs-number">2</span>:])<span class="hljs-comment">// 默认结束索引为len</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/b36c2af7/3.png" class="" title="运行结果"><h2 id="len和cap"><a href="#len和cap" class="headerlink" title="len和cap"></a>len和cap</h2><p>长度和容量区别：</p><ul><li>长度：长度表示切片中实际存储的元素个数</li><li>容量：容量表示切片底层使用的数组的大小</li></ul><p>当定义一个切片时，如果没有通过make方法指定cap，则底层会申请一个和切片长度一样的数组，这个数组的大小就是cap，当使用append朝切片中追加元素时，如果追加元素后新的len小于cap，则底层数组不会改变，当新的len大于cap时，底层就会重新申请一个数组，且数组的长度为cap * 2，然后将之前数组的元素全部复制到新数组中。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<br>fmt.Printf(<span class="hljs-string">&quot;len:%d, cap:%d \n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s))<span class="hljs-comment">// 此时len=3，cap=3</span><br><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>)<br>fmt.Printf(<span class="hljs-string">&quot;len:%d, cap:%d \n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s))<span class="hljs-comment">// append一个元素，len=4，大于cap，所以底层数组扩容，cap=6</span><br><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>)<br>fmt.Printf(<span class="hljs-string">&quot;len:%d, cap:%d \n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s))<span class="hljs-comment">// append一个元素，len=5，小于cap，底层数组不变，cap=6</span><br><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>)<br>fmt.Printf(<span class="hljs-string">&quot;len:%d, cap:%d \n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s))<span class="hljs-comment">// append一个元素，len=6，小于cap，底层数组不变，cap=6</span><br><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>)<br>fmt.Printf(<span class="hljs-string">&quot;len:%d, cap:%d \n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s))<span class="hljs-comment">// append一个元素，len=7，大于cap，所以底层数组扩容，cap=12</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/b36c2af7/4.png" class="" title="运行结果">]]></content>
    
    
    <summary type="html">在go语言中，切片是对数组的抽象，数组在声明时指定了长度之后就不可再进行改变，在特定场景下数组就不适用，所以就有了切片类型，切片就是“动态数组”，和数组相比，切片的长度是不固定的，可以在切片后面追加元素，长度自动扩容。</summary>
    
    
    
    <category term="Go语言入门" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Golang入门" scheme="http://example.com/tags/Golang%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Go语言入门06——数组</title>
    <link href="http://example.com/p/699b173c.html"/>
    <id>http://example.com/p/699b173c.html</id>
    <published>2024-09-28T04:12:57.000Z</published>
    <updated>2024-10-15T09:27:38.243Z</updated>
    
    <content type="html"><![CDATA[<p>数组是相同数据类型的一组长度固定的序列，类型可以是整形、字符串和浮点型等，数组元素可以通过索引来读取或者修改，索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推，最后一个元素的索引为数组长度减1。</p><img src="/p/699b173c/1.png" class="" title="数组"><h2 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h2><p>声明数组必须指定元素类型和数组长度，数组一旦声明，长度就不可变。</p><p>语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> 数组名 [数组长度] 元素类型<br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> intArr [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><span class="hljs-comment">// 声明一个长度为5的int类型数组</span><br><span class="hljs-keyword">var</span> floatArr [<span class="hljs-number">5</span>]<span class="hljs-type">float32</span><span class="hljs-comment">// 声明一个长度为5的float32类型数组</span><br><span class="hljs-keyword">var</span> strArr [<span class="hljs-number">5</span>]<span class="hljs-type">string</span><span class="hljs-comment">// 声明一个长度为5的string类型数组</span><br><span class="hljs-keyword">var</span> boolArr [<span class="hljs-number">5</span>]<span class="hljs-type">bool</span><span class="hljs-comment">// 声明一个长度为5的bool类型数组</span><br>fmt.Println(intArr)<br>fmt.Println(floatArr)<br>fmt.Println(strArr)<br>fmt.Println(boolArr)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于只是声明了数组，并没有给数组初始化，所以输出均是打印的其类型相对应的默认值。</p><p>运行结果：</p><img src="/p/699b173c/2.png" class="" title="输出结果"><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>数组初始化时，可以在声明数组时使用大括号<code>&#123;&#125;</code>初始化，或者在数组声明完成之后使用索引对数组中指定位置的元素进行初始化，<strong>在指定了数组长度的情况下，初始化中的数组个数不能超过数组长度。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> intArr = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>如果数组长度不确定，可以使用<code>...</code>代替数组长度，编译器在编译时会根据元素个数自动推断数组长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> floatArr = [...]<span class="hljs-type">float32</span>&#123;<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>&#125;<br></code></pre></td></tr></table></figure><p>在数组声明之后，可使用索引的方式初始化数组中的元素，索引从0开始，最后一个元素索引为长度减1，不能超过最后一个元素的索引。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> strArr [<span class="hljs-number">5</span>]<span class="hljs-type">string</span><br>strArr[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;A&quot;</span><br>strArr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;B&quot;</span><br>strArr[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;C&quot;</span><br>strArr[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;D&quot;</span><br>strArr[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;E&quot;</span><br></code></pre></td></tr></table></figure><h2 id="数组访问和遍历"><a href="#数组访问和遍历" class="headerlink" title="数组访问和遍历"></a>数组访问和遍历</h2><p>访问数组中的元素可以使用数组名加中括号<code>[]</code>，在中括号中指定元素索引的方式访问，使用索引访问元素时，索引不能超过数组的长度减1。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> intArr = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;第1个元素是：&quot;</span>, intArr[<span class="hljs-number">0</span>])<br>fmt.Println(<span class="hljs-string">&quot;第2个元素是：&quot;</span>, intArr[<span class="hljs-number">1</span>])<br>fmt.Println(<span class="hljs-string">&quot;第3个元素是：&quot;</span>, intArr[<span class="hljs-number">2</span>])<br>fmt.Println(<span class="hljs-string">&quot;第4个元素是：&quot;</span>, intArr[<span class="hljs-number">3</span>])<br>fmt.Println(<span class="hljs-string">&quot;第5个元素是：&quot;</span>, intArr[<span class="hljs-number">4</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/699b173c/3.png" class="" title="输出结果"><p>通过数组索引的方式访问数组方便简洁，但是如果数组长度太长，使用索引的方式访问就不太优雅，这时候就需要使用到数据遍历的功能，数组遍历可以使用<code>for</code>循环的方式进行遍历。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> intArr = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(intArr); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;第%d个元素是： %d \n&quot;</span>, i + <span class="hljs-number">1</span>, intArr[i])<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用for循环的方式遍历数组intArr，输出结果和上面索引方式一样。</p><p>除了使用这种for循环之外，还可以使用<code>for range</code>方式的循环来遍历数组，使用<code>for range</code>遍历更加方便</p><p><code>**for range**</code><strong>使用方式见之前内容。</strong></p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> intArr = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> intArr &#123;<br>fmt.Printf(<span class="hljs-string">&quot;第%d个元素是： %d \n&quot;</span>, i + <span class="hljs-number">1</span>, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用该方法输出结果同上面一样。</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>前面所提到的都是一位数组，在go语言中，还有多维数组的概念，但是多维数组中使用到的最多的就是二维数组，所谓二维数组，其本质上可以看做是多个一位数组组成的。</p><img src="/p/699b173c/4.png" class="" title="二位数组"><p>如上图所示，就是一个简单的二维数组，可以将该二维数组看做是由三个一维数组所组成，就构成了一个表格的形式，访问二维数组需要指定行索引和列索引，且索引都是从0开始，可以使用<code>arr[i][j]</code>来访问，i表示行，j表示列。</p><p>二维数组声明和一维数组类似：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> 数组名 [行数][列数] 数组类型<br></code></pre></td></tr></table></figure><p>二维数组声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> intArr [<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>二维数组声明并初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>intArr := [<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<span class="hljs-type">int</span>&#123;<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; ,   <span class="hljs-comment">// 第一行</span><br>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125; ,   <span class="hljs-comment">// 第二行</span><br>&#123;<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;,  <span class="hljs-comment">// 第三行</span><br>&#125;<br>fmt.Println(intArr)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/699b173c/5.png" class="" title="输出结果"><p>二维数组可以使用<code>arr[i][j]</code>方式进行访问，i表示行，j表示列，i和j都不能超过索引。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>intArr := [<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;,<br>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;,<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;第1行第1列：&quot;</span>, intArr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>fmt.Println(<span class="hljs-string">&quot;第1行第2列：&quot;</span>, intArr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])<br>fmt.Println(<span class="hljs-string">&quot;第1行第3列：&quot;</span>, intArr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>])<br>fmt.Println(<span class="hljs-string">&quot;第2行第1列：&quot;</span>, intArr[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br>fmt.Println(<span class="hljs-string">&quot;第2行第2列：&quot;</span>, intArr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<br>fmt.Println(<span class="hljs-string">&quot;第2行第3列：&quot;</span>, intArr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>])<br>fmt.Println(<span class="hljs-string">&quot;第3行第1列：&quot;</span>, intArr[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>])<br>fmt.Println(<span class="hljs-string">&quot;第3行第2列：&quot;</span>, intArr[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>])<br>fmt.Println(<span class="hljs-string">&quot;第3行第3列：&quot;</span>, intArr[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/699b173c/6.png" class="" title="输出结果"><p>二维数组同样可以使用for循环进行遍历，一维数组使用一个for循环进行遍历，二维数组则使用两个for嵌套循环即可遍历。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>intArr := [<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;,<br>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(intArr); i++ &#123;<span class="hljs-comment">// len(intArr)获取到的是intArr的行数，intArr[i] 表示一个一维数组</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(intArr[i]); j++ &#123;<span class="hljs-comment">// 按照一维数组的方式遍历即可</span><br>fmt.Printf(<span class="hljs-string">&quot;第%d行第%d列：%d \n&quot;</span>, i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, intArr[i][j])<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法使用两个for循环嵌套，外层循环控制二维数组的行数，len(intArr)获取到的是二维数组的总行数，内层循环控制二维数组的列数，len(intArr[i])获取到的是二维数组当前行的列数，运行结果和上面一样。</p><p>使用<code>for range</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>intArr := [<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;,<br>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> intArr &#123;<span class="hljs-comment">// 直接循环intArr，获取到的每一个v为一个一维数组</span><br><span class="hljs-keyword">for</span> i1, v1 := <span class="hljs-keyword">range</span> v &#123;<span class="hljs-comment">// 按照一维数组的方式遍历即可</span><br>fmt.Printf(<span class="hljs-string">&quot;第%d行第%d列：%d \n&quot;</span>, i + <span class="hljs-number">1</span>, i1 + <span class="hljs-number">1</span>, v1)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果同上。</p>]]></content>
    
    
    <summary type="html">数组是相同数据类型的一组长度固定的序列，类型可以是整形、字符串和浮点型等，数组元素可以通过索引来读取或者修改，索引从 0 开始。</summary>
    
    
    
    <category term="Go语言入门" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Golang入门" scheme="http://example.com/tags/Golang%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Go语言入门05——循环语句</title>
    <link href="http://example.com/p/7e7c57a1.html"/>
    <id>http://example.com/p/7e7c57a1.html</id>
    <published>2024-09-22T05:35:59.000Z</published>
    <updated>2024-10-15T09:27:38.239Z</updated>
    
    <content type="html"><![CDATA[<p>循环语句是一个编程语言中不可缺少的一部分，循环通常用来完成具有规律性的重复性的操作，例如通过循环计算1到100的累加或者累乘。</p><p>for循环是一个循环控制语句，在go语言中，for循环一共有三种方式</p><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><p>语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> init; condition; post &#123;<br>    <span class="hljs-comment">// 循环执行的语句</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这种循环方式中，可指定循环的次数。</p><p>init：赋值表达式，用于给控制变量赋初值<br>condition：条件表达式，用于控制循环<br>post：赋值表达式，用于给控制变量做增量或减量</p><p>循环执行步骤：</p><ol><li>通过init给控制变量赋值</li><li>判断condition是否为true，如果为true则执行循环体内的代码</li><li>循环体内的代码执行完之后通过post对控制变量进行增量或减量</li><li>返回第2步继续判断，然后第2、3步持续循环，知道condition为false时跳出循环</li></ol><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 计算从1到100的累加结果</span><br><span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++ &#123;<br>sum += i<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;1到100累加结果为：&quot;</span>, sum)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/7e7c57a1/1.png" class="" title="输出结果"><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p>在第一种循环的基础上，init和post不是必须存在，可以没有init或者没有post，或者两个都没有都可以，</p><p>语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> condition &#123; <br><span class="hljs-comment">// 循环执行的语句</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 计算1到10累乘结果</span><br><span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br>i := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i &lt;= <span class="hljs-number">10</span> &#123;<br>sum *= i<br>i++<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;1到10累乘结果为：&quot;</span>, sum)<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种特殊的循环就是无限循环，无限循环就是表示没有终止条件的循环，这样for循环体中的代码就会无休止的一直执行，在实际开发中要注意避免无限循环情况的发生。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        sum := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            sum++ <span class="hljs-comment">// 无限循环累加</span><br>        &#125;<br>        fmt.Println(sum) <span class="hljs-comment">// 无法输出</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h2><p>第三种循环是用于数组、切片等输出的循环，在这种循环中，需要使用到一个关键字range，range后面紧跟的是需要遍历的数组或切片，range前面可以使用两个变量进行接收数据，第一个变量会接收到数组或切片的下标，第二个变量会接收到数组或切片的值，在循环的过程中，会把数组或切片中的下标和值依次一个个取出来赋值给index和value。</p><p>语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> variable &#123;<br>    <span class="hljs-comment">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>numbers := [<span class="hljs-number">9</span>]<span class="hljs-type">int</span> &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> numbers &#123;<br>fmt.Printf(<span class="hljs-string">&quot;第%d个数是：%d \n&quot;</span>, i, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/7e7c57a1/2.png" class="" title="输出结果"><p>由于数组和切片的下标是从0开始的，所以第一行显示的是第0个数。</p><p><strong>tips：数组和切片后面会详细介绍</strong></p><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>break语句的作用是在循环中跳出循环，或者在switch中执行一个case后跳出swit。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sum := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> &#123;<br>sum++<br><span class="hljs-keyword">if</span> sum &gt; <span class="hljs-number">10</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>fmt.Println(sum)<span class="hljs-comment">// 输出11</span><br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这里使用的for循环是一个死循环，但是在循环体内进行了判断，当sum的值大于10的时候就跳出循环，所以该循环不会无休止的执行下去，而是会在sum加到11时就跳出循环。</p><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>continue和break用法类似，但是和break直接跳出循环不一样的是，continue并不是直接跳出循环，而是结束本轮循环，执行post对控制变量进行增量或减量后进行下一轮循环。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 计算1到100之间所有奇数的和</span><br><span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++ &#123;<br>        <span class="hljs-comment">// 当i取余2为0时，则表示当前数为偶数，不参与计算，通过continue跳出本轮循环开始下一轮循环</span><br><span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>sum += i<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;1到100之间奇数和为：&quot;</span>, sum)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/7e7c57a1/3.png" class="" title="输出结果">]]></content>
    
    
    <summary type="html">循环语句是一个编程语言中不可缺少的一部分，循环通常用来完成具有规律性的重复性的操作，例如通过循环计算1到100的累加或者累乘。</summary>
    
    
    
    <category term="Go语言入门" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Golang入门" scheme="http://example.com/tags/Golang%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Go语言入门04——条件语句</title>
    <link href="http://example.com/p/3f78afe9.html"/>
    <id>http://example.com/p/3f78afe9.html</id>
    <published>2024-09-22T05:27:35.000Z</published>
    <updated>2024-10-15T09:27:38.230Z</updated>
    
    <content type="html"><![CDATA[<p>条件语句就是根据不同的条件执行不同的代码。</p><p>示意图：</p><img src="/p/3f78afe9/1.png" class="" title="结构图"><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>if语句用于判断某个条件是否满足，当条件满足时则执行if语句块中的代码。</p><p>语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 条件表达式 &#123;<br>   <span class="hljs-comment">// 当条件表达式为true时执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>score := <span class="hljs-number">90</span><br><span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">90</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;优秀&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为表达式<code>score &gt;= 90</code>的结果为true，则会在控制台打印出<code>优秀</code></p><p>运行结果：</p><img src="/p/3f78afe9/2.png" class="" title="输出结果"><h2 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h2><p>在if条件语句中，如果表达式为true则会执行if语句块中的代码，在if后还可以增加else语句块，则表示当if条件为false时执行else中的代码。</p><p>语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 条件表达式 &#123;<br>   <span class="hljs-comment">// 当条件表达式为true时执行</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 当条件表达式为false时执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>score := <span class="hljs-number">80</span><br><span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">90</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;优秀&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;一般&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>score &#x3D; 80，由于表达式<code>score &gt;= 90</code>结果为false，则不会执行if中的语句块，会转而执行else中的语句块。</p><p>运行结果：</p><img src="/p/3f78afe9/3.png" class="" title="输出结果"><p>除了直接使用<code>if...else</code>之外，还可以在else后面继续增加if条件判断。</p><p>语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 条件表达式<span class="hljs-number">1</span> &#123;<br>   <span class="hljs-comment">// 当条件表达式1为true时执行</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> 条件表达式<span class="hljs-number">2</span> &#123;<br>    <span class="hljs-comment">// 当条件表达式2为true时执行</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 当条件表达式1和2都不为true时执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>score := <span class="hljs-number">80</span><br><span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">90</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;优秀&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">80</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;良好&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;一般&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/3f78afe9/4.png" class="" title="输出结果"><p><code>if...else if</code>判断没有数量限制，可一直添加<code>else if</code>判断，但是在实际开发中不建议写太多，如果有特别多得条件需要判断，可使用switch进行判断</p><h2 id="if嵌套"><a href="#if嵌套" class="headerlink" title="if嵌套"></a>if嵌套</h2><p>if嵌套表示可以在if语句块中添加if判断</p><p>语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 条件表达式<span class="hljs-number">1</span> &#123;<br>    <span class="hljs-keyword">if</span> 条件表达式<span class="hljs-number">2</span> &#123;<br>        <span class="hljs-comment">// 当条件表达式2为true时执行</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 当条件表达式2为false时执行</span><br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 当条件表达式1为false时执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>score := <span class="hljs-number">90</span><br><span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">90</span> &#123;<br><span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">95</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;非常优秀&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;优秀&quot;</span>)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;一般&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>score = 90</code>，则第一层if判断<code>score &gt;= 90</code>为true，则进入到第一层if语句块中，在第一层语句块中<code>score &gt;= 95</code>为false，则执行else中的代码，最后输出为优秀。</p><p>运行结果：</p><img src="/p/3f78afe9/5.png" class="" title="输出结果"><p>if嵌套也可以无限制的嵌套，但是在实际开发中同样不建议嵌套太多层。</p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>switch语句是根据变量的值执行不同的case，在执行的过程中，会从第一个case开始判断，直到碰到一个符合条件的case为止，然后执行该case中的语句，不同于java的是不需要在每一个case中添加break语句，go语言默认情况下case后面自带break语句。</p><p>语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> 变量 &#123;<br>    <span class="hljs-keyword">case</span> 变量<span class="hljs-number">1</span>:<br>        <span class="hljs-comment">// 当变量和变量1相等时执行</span><br>    <span class="hljs-keyword">case</span> 变量<span class="hljs-number">2</span>:<br>        <span class="hljs-comment">// 当变量和变量2相等时执行</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// 当没有符合的case时执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>score := <span class="hljs-number">80</span><br><span class="hljs-keyword">switch</span> score &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">90</span>:fmt.Println(<span class="hljs-string">&quot;优秀&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">80</span>:fmt.Println(<span class="hljs-string">&quot;良好&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">70</span>:fmt.Println(<span class="hljs-string">&quot;一般&quot;</span>)<br><span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;默认&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/3f78afe9/6.png" class="" title="输出结果"><p>switch的变量可以时任意类型，而case的变量可以是相同类型的任意值，类型不局限，但是switch和case的类型必须时相同的类型，同样case还可以为表达式。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>score := <span class="hljs-number">80</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">90</span>:fmt.Println(<span class="hljs-string">&quot;优秀&quot;</span>)<br><span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">80</span>:fmt.Println(<span class="hljs-string">&quot;良好&quot;</span>)<br><span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">70</span>:fmt.Println(<span class="hljs-string">&quot;一般&quot;</span>)<br><span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;默认&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当case为表达式时，则switch中就不需要再写变量。</p><p>运行结果：</p><img src="/p/3f78afe9/7.png" class="" title="输出结果"><h3 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h3><p>由于在go语言中每一个case后面都会默认加上break，所以每次匹配都执行其中的一个case，但是如果需要执行后面的case，则可以使用fallthrough，使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>score := <span class="hljs-number">80</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">90</span>:<br>fmt.Println(<span class="hljs-string">&quot;优秀&quot;</span>)<br><span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">80</span>:<br>fmt.Println(<span class="hljs-string">&quot;良好&quot;</span>)<br><span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">70</span>:<br>fmt.Println(<span class="hljs-string">&quot;一般&quot;</span>)<br><span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;默认&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于在每个case后面都增加了fallthrough，则当<code>case score &gt;= 80</code>匹配时，除了执行该case中的语句外，还会直接之后它后面的所有case，并且不会判断case是否为true。</p><p>运行结果：</p><img src="/p/3f78afe9/8.png" class="" title="输出结果">]]></content>
    
    
    <summary type="html">条件语句就是根据不同的条件执行不同的代码。</summary>
    
    
    
    <category term="Go语言入门" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Golang入门" scheme="http://example.com/tags/Golang%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于角色的访问控制：RBAC权限模型详解</title>
    <link href="http://example.com/p/8ac4d780.html"/>
    <id>http://example.com/p/8ac4d780.html</id>
    <published>2024-09-08T06:11:38.000Z</published>
    <updated>2024-10-15T09:27:38.263Z</updated>
    
    <content type="html"><![CDATA[<p>在信息技术飞速发展的今天，数据安全和系统访问控制成为了保护企业资产的关键。基于角色的访问控制（RBAC，Role-Based Access Control）模型作为一种有效的权限管理策略，被广泛应用于各种信息系统中。下面将详细介绍RBAC模型及其不同版本的实现和应用。</p><h2 id="1-什么是RBAC"><a href="#1-什么是RBAC" class="headerlink" title="1. 什么是RBAC"></a>1. 什么是RBAC</h2><p>RBAC模型是一种将用户与权限通过角色进行关联的权限管理机制。在这种模型中，权限不是直接分配给用户，而是分配给角色，用户通过拥有角色来间接获得权限。这种间接的权限分配方式简化了权限管理，提高了系统的安全性和灵活性。</p><p>那为什么需要角色这个概念呢？假设多个用户拥有相同的权限，如果不使用角色概念，就需要为所有用户一一分配权限，同时如果需要修改权限的话也需要对所有用户一一修改，这样既费力又还有出错的可能，如果引入了角色概念，则只需要给角色相应的权限，再将角色给用户，这样在批量修改权限时可大幅提升效率，同时降低出错的概率。</p><img src="/p/8ac4d780/1.png" class="" title="RBAC"><p>用户和角色直接可以是一对多或者多对多的关系。</p><ul><li>一对多：一个用户只能有一个角色，一个角色可以被多个用户拥有；</li><li>多对多：一个用户可以有多个角色，一个角色可以被多个用户拥有；</li></ul><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>假设一个公司有员工、经理和管理员三种角色。员工可以访问客户信息，经理可以访问客户信息并审批请假，而管理员可以访问所有系统设置。在RBAC模型中，我们首先定义这些角色及其权限，然后将角色分配给相应的员工。</p><h2 id="2-RBAC1"><a href="#2-RBAC1" class="headerlink" title="2. RBAC1"></a>2. RBAC1</h2><p>在上面的实际应用中，员工、经理和管理员三种角色的权限有重叠部分，这个时候在给角色赋权限的时候会存在大量重复的权限，因此可以使用RBAC模型的升级模型RBAC1。</p><p>RBAC1是在基础RBAC模型上增加了角色层次结构的模型。它允许角色之间存在继承关系，即一个角色可以继承另一个角色的权限。这种模型适用于具有明确层级关系的组织结构。</p><img src="/p/8ac4d780/2.png" class="" title="RBAC1"><h3 id="实际应用-1"><a href="#实际应用-1" class="headerlink" title="实际应用"></a>实际应用</h3><p>在上面的示例中稍加更改，经理可以继承员工的权限，并额外增加自己的权限，主管可以继承经理的权限再增加额外的权限，一层层的继承可以很好解决大量重复的权限赋予以及具有明确的层级关系。</p><h2 id="3-RBAC2"><a href="#3-RBAC2" class="headerlink" title="3. RBAC2"></a>3. RBAC2</h2><p>RBAC2模型在RBAC1的基础上增加了角色的限制条件，包括角色互斥、角色数量限制、角色条件等。</p><ul><li>角色互斥：一个用户不能同时拥有两个互斥的角色，互斥角色就是权限相互制约的两个角色，例如在银行系统中，一个用户不能同时拥有会计和审计两个角色。</li><li>数量限制：指的是一个角色被分配的数量受到限制，例如在公司系统中，CEO角色只能分配给1个人。</li><li>角色条件：角色条件指的是在获取某个权限时必须有一个先决条件，例如在申请经理的角色时，必须先有副经理的角色权限，这样可以避免用户随意申请任意角色，虽然管理员可以不同意，但还是无形之中增加了管理员的工作量。</li></ul><h2 id="4-RBAC3"><a href="#4-RBAC3" class="headerlink" title="4. RBAC3"></a>4. RBAC3</h2><p>RBAC3是RBAC1和RBAC2的结合体，它既包括角色继承，也包括角色限制等。这个模型提供了最全面的访问控制功能，能够满足复杂的权限管理需求。</p><p>虽然RBAC是最全面的角色权限控制模型，但是在实际应用中，还是需要根据不同的情况使用不同的模型，模型只是一个基础框架，只要有了基本的框架概念，可以任意对模型进行合理化的增减，以此达到最适合自己的权限控制系统。</p>]]></content>
    
    
    <summary type="html">基于角色的访问控制（RBAC，Role-Based Access Control）模型作为一种有效的权限管理策略，被广泛应用于各种信息系统中。</summary>
    
    
    
    <category term="通用技术" scheme="http://example.com/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="RBAC" scheme="http://example.com/tags/RBAC/"/>
    
    <category term="权限控制" scheme="http://example.com/tags/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Go语言入门03——运算符</title>
    <link href="http://example.com/p/def899cd.html"/>
    <id>http://example.com/p/def899cd.html</id>
    <published>2024-09-08T04:44:16.000Z</published>
    <updated>2024-10-15T09:27:38.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>假设a为3，b为2</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加法运算符</td><td align="left">a + b &#x3D; 5</td></tr><tr><td align="left">-</td><td align="left">减法运算符</td><td align="left">a - b &#x3D; 1</td></tr><tr><td align="left">*</td><td align="left">乘法运算符</td><td align="left">a * b &#x3D; 6</td></tr><tr><td align="left">&#x2F;</td><td align="left">除法运算符</td><td align="left">a &#x2F; b &#x3D; 1</td></tr><tr><td align="left">%</td><td align="left">取余运算符</td><td align="left">a % b &#x3D; 1</td></tr><tr><td align="left">++</td><td align="left">自增运算符</td><td align="left">a++ &#x3D; 4</td></tr><tr><td align="left">–</td><td align="left">自减运算符</td><td align="left">b– &#x3D; 1</td></tr></tbody></table><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">3</span><br>b := <span class="hljs-number">2</span><br>fmt.Println(<span class="hljs-string">&quot;a + b = &quot;</span>, a + b)<br>fmt.Println(<span class="hljs-string">&quot;a - b = &quot;</span>, a - b)<br>fmt.Println(<span class="hljs-string">&quot;a * b = &quot;</span>, a * b)<br>fmt.Println(<span class="hljs-string">&quot;a / b = &quot;</span>, a / b)<br>fmt.Println(<span class="hljs-string">&quot;a % b = &quot;</span>, a % b)<br>a++<br>b--<br>fmt.Println(<span class="hljs-string">&quot;a ++ = &quot;</span>, a)<br>fmt.Println(<span class="hljs-string">&quot;b -- = &quot;</span>, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/def899cd/1.png" class="" title="结果1"><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>假设a为3，b为2</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">&#x3D;&#x3D;</td><td align="left">判断两个值是否相等，如果相等返回true，否则返回false</td><td align="left">a &#x3D;&#x3D; b 为 false</td></tr><tr><td align="left">!&#x3D;</td><td align="left">判断两个值是否不相等，如果不相等返回true 否则返回false</td><td align="left">a !&#x3D; b 为 true</td></tr><tr><td align="left">&gt;</td><td align="left">判断左边值是否大于右边值，如果是返回true 否则返回false</td><td align="left">a &gt; b 为 true</td></tr><tr><td align="left">&lt;</td><td align="left">判断左边值是否小于右边值，如果是返回true 否则返回false</td><td align="left">a &lt; b 为 false</td></tr><tr><td align="left">&gt;&#x3D;</td><td align="left">判断左边值是否大于等于右边值，如果是返回true 否则返回false</td><td align="left">a &gt;&#x3D; b 为 true</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">判断左边值是否小于等于右边值，如果是返回true 否则返回false。</td><td align="left">a &lt;&#x3D; b 为 false</td></tr></tbody></table><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">3</span><br>b := <span class="hljs-number">2</span><br>fmt.Println(<span class="hljs-string">&quot;a == b : &quot;</span>, a == b)<br>fmt.Println(<span class="hljs-string">&quot;a != b : &quot;</span>, a != b)<br>fmt.Println(<span class="hljs-string">&quot;a &gt; b : &quot;</span>, a &gt; b)<br>fmt.Println(<span class="hljs-string">&quot;a &lt; b : &quot;</span>, a &lt; b)<br>fmt.Println(<span class="hljs-string">&quot;a &gt;= b : &quot;</span>, a &gt;= b)<br>fmt.Println(<span class="hljs-string">&quot;a &lt;= b : &quot;</span>, a &lt;= b)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/def899cd/2.png" class="" title="结果2"><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>假设a为true，b为false</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">逻辑与运算符，如果两边都为true，则为true，否则为false</td><td align="left">a &amp;&amp; b 为 false</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">!</td><td align="left">逻辑非运算符，如果为true，返回false，如果为false，返回true</td><td align="left">!a 为 false， !b 为true</td></tr></tbody></table><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-literal">true</span><br>b := <span class="hljs-literal">false</span><br>fmt.Println(<span class="hljs-string">&quot;a &amp;&amp; b : &quot;</span>, a &amp;&amp; b)<br>fmt.Println(<span class="hljs-string">&quot;a || b : &quot;</span>, a || b)<br>fmt.Println(<span class="hljs-string">&quot;!a : &quot;</span>, !a)<br>fmt.Println(<span class="hljs-string">&quot;!b : &quot;</span>, !b)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/def899cd/3.png" class="" title="结果3"><p>注意：逻辑运算符通常用于在if条件中做判断使用，并且逻辑运算符可以与关系运算符结合使用，例如 <code>a &gt; b &amp;&amp; b &gt; c</code>，当a 大于 b，并且b 大于 c 时则为true，否则为false。</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符是对整数的二进制进行计算</p><p>假设a为3，b为2</p><p>则a转为二进制为：0011，b的二进制为：0010</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">a &amp; b的计算方式步骤：<br>第一步：将a和b转为二进制<br>a = 0011    b = 0010<br>第二步：将转为二进制的两个数进行按位与运算<br>按位与运算规则：对应的两位数都为1则结果为1，计算结果如下<br>a:   0011<br>b:   0010<br>&amp;   ------<br>结果：0010<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与运算符，将两边的整数作为二进制进行按位与运算，两位都为1则为1</td><td align="left">a &amp; b &#x3D; 2，二进制为0010</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">按位或运算符，将两边的整数作为二进制进行按位或运算，两位其中一个为1，则为1</td></tr><tr><td align="left">^</td><td align="left">异或运算符，将两边的整数作为二进制进行按位或运算，两位不相同则为1</td><td align="left">a ^ b &#x3D; 1，二进制为0001</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移运算符，将左边的数转为二进制后向左位移右边指定的位数，左移n位就是乘以2的n次方</td><td align="left">a &lt;&lt; 2 结果为12 ，二进制为 1100</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移运算符，将左边的数转为二进制后向右位移右边指定的位数，右移n位就是除以2的n次方</td><td align="left">a &gt;&gt; 2 结果为0 ，二进制为 0000</td></tr></tbody></table><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">3</span><br>b := <span class="hljs-number">2</span><br>fmt.Println(<span class="hljs-string">&quot;a &amp; b = &quot;</span>, a &amp; b)<br>fmt.Println(<span class="hljs-string">&quot;a | b = &quot;</span>, a | b)<br>fmt.Println(<span class="hljs-string">&quot;a ^ b = &quot;</span>, a ^ b)<br>fmt.Println(<span class="hljs-string">&quot;a &lt;&lt; 2 = &quot;</span>, a &lt;&lt; <span class="hljs-number">2</span>)<br>fmt.Println(<span class="hljs-string">&quot;a &gt;&gt; 2 = &quot;</span>, a &gt;&gt; <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/def899cd/4.png" class="" title="结果4"><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">赋值运算符，将右边表达式的值赋值给左边变量</td><td align="left">c &#x3D; a + b  &#x3D;&gt; 表达式 a + b的结果赋值给变量c</td></tr><tr><td align="left">+&#x3D;</td><td align="left">相加后再赋值</td><td align="left">a +&#x3D; b  &#x3D;&gt; a &#x3D; a + b</td></tr><tr><td align="left">-&#x3D;</td><td align="left">相减后再赋值</td><td align="left">a -&#x3D; b  &#x3D;&gt; a &#x3D; a - b</td></tr><tr><td align="left">*&#x3D;</td><td align="left">相乘后再赋值</td><td align="left">a _&#x3D; b  &#x3D;&gt; a &#x3D; a _ b</td></tr><tr><td align="left">&#x2F;&#x3D;</td><td align="left">相除后再赋值</td><td align="left">a &#x2F;&#x3D; b  &#x3D;&gt; a &#x3D; a &#x2F; b</td></tr><tr><td align="left">%&#x3D;</td><td align="left">求余后再赋值</td><td align="left">a %&#x3D; b  &#x3D;&gt; a &#x3D; a % b</td></tr><tr><td align="left">&lt;&lt;&#x3D;</td><td align="left">左移后赋值</td><td align="left">a &lt;&lt;&#x3D; 2 &#x3D;&gt; a &#x3D; a &lt;&lt; 2</td></tr><tr><td align="left">&gt;&gt;&#x3D;</td><td align="left">右移后赋值</td><td align="left">a &gt;&gt;&#x3D; 2 &#x3D;&gt; a &#x3D; a &gt;&gt; 2</td></tr><tr><td align="left">&amp;&#x3D;</td><td align="left">按位与后赋值</td><td align="left">a &amp;&#x3D; 2 &#x3D;&gt; a &#x3D; a &amp; 2</td></tr><tr><td align="left">^&#x3D;</td><td align="left">按位异或后赋值</td><td align="left">a ^&#x3D; 2 &#x3D;&gt; a &#x3D; a ^ 2</td></tr><tr><td align="left"></td><td align="left">&#x3D;</td><td align="left">按位或后赋值</td></tr></tbody></table><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">3</span><br>b := <span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> c <span class="hljs-type">int</span><br>c = a + b<br>fmt.Println(<span class="hljs-string">&quot;c = &quot;</span>, c)<br>a += b<br>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<br>a -= b<br>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<br>a *= b<br>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<br>a /= b<br>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/def899cd/5.png" class="" title="结果5"><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>由上到下代表优先级从高到低，相同优先级的运算符在计算的过程中按照从左往右依次计算，同时还可以临时使用小括号提高优先级。</p><table><thead><tr><th align="left">优先级</th><th align="left">运算符</th></tr></thead><tbody><tr><td align="left">5</td><td align="left">* &#x2F; % &lt;&lt; &gt;&gt; &amp; &amp;^</td></tr><tr><td align="left">4</td><td align="left">+ -</td></tr><tr><td align="left">3</td><td align="left">&#x3D;&#x3D; !&#x3D; &lt; &lt;&#x3D; &gt; &gt;&#x3D;</td></tr><tr><td align="left">2</td><td align="left">&amp;&amp;</td></tr><tr><td align="left">1</td><td align="left"></td></tr></tbody></table><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">20</span><br>b := <span class="hljs-number">10</span><br>c := <span class="hljs-number">15</span><br>d := <span class="hljs-number">5</span><br>fmt.Println(<span class="hljs-string">&quot;(a + b) * c / d = &quot;</span>, ( a + b ) * c / d)<br>fmt.Println(<span class="hljs-string">&quot;((a + b) * c) / d = &quot;</span>, (( a + b) * c) / d)<br>fmt.Println(<span class="hljs-string">&quot;(a + b) * (c / d) = &quot;</span>, (a + b) * (c / d))<br>fmt.Println(<span class="hljs-string">&quot;a + (b * c) / d = &quot;</span>, a + (b * c) / d)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/p/def899cd/6.png" class="" title="结果6">]]></content>
    
    
    <summary type="html">运算符用于在程序运行时执行数学或逻辑运算。</summary>
    
    
    
    <category term="Go语言入门" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Golang入门" scheme="http://example.com/tags/Golang%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Go语言入门02——数据类型</title>
    <link href="http://example.com/p/3d95b216.html"/>
    <id>http://example.com/p/3d95b216.html</id>
    <published>2024-09-03T11:32:24.000Z</published>
    <updated>2024-10-15T09:27:38.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见基本数据类型"><a href="#常见基本数据类型" class="headerlink" title="常见基本数据类型"></a>常见基本数据类型</h2><ul><li><strong>uint8</strong>：无符号<code>8</code>位整形，取值范围：<code>0-255</code></li><li><strong>uint16</strong>：无符号<code>16</code>位整形，取值范围：<code>0-65535</code></li><li><strong>uint32</strong>：无符号<code>32</code>位整形，取值范围：<code>0-4294967295</code></li><li><strong>uint64</strong>：无符号<code>64</code>位整形，取值范围：<code>0-18446744073709551615</code></li><li><strong>uint</strong>：<code>32</code> 或<code> 64</code> 位</li><li><strong>int8</strong>：有符号<code>8</code>位整形，取值范围：<code>-128-127</code></li><li><strong>int16</strong>：有符号<code>16</code>位整形，取值范围：<code>-32768-32767</code></li><li><strong>int32</strong>：有符号<code>32</code>位整形，取值范围：<code>-2147483648-2147483647</code></li><li><strong>int64</strong>：有符号<code>64</code>位整形，取值范围：<code>-9223372036854775808-9223372036854775807</code></li><li><strong>int</strong>：与<code>uint</code>一样大小</li><li><strong>byte</strong>：类似 <code>uint8</code></li><li><strong>rune</strong>：类似 <code>int32</code></li><li><strong>float32</strong>：<code>32</code>位浮点类型</li><li><strong>float64</strong>：<code>64</code>位浮点类型</li><li><strong>string</strong>：字符串</li><li><strong>bool</strong>：布尔类型，取值<code>true</code>或<code>false</code></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Go 语言变量名由字母、数字、下划线组成，首字符不能为数字，不能使用关键字作为变量名。</p><p>Go语言中的25个关键字：</p><img src="/p/3d95b216/1.png" class="" title="关键字"><h3 id="使用关键字var，并指定变量类型"><a href="#使用关键字var，并指定变量类型" class="headerlink" title="使用关键字var，并指定变量类型"></a>使用关键字var，并指定变量类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明单个变量</span><br><span class="hljs-keyword">var</span> 变量名 变量类型<br><span class="hljs-comment">// 声明多个变量</span><br><span class="hljs-keyword">var</span> 变量名<span class="hljs-number">1</span>, 变量名<span class="hljs-number">2</span> 变量类型<br></code></pre></td></tr></table></figure><p>初始化变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明并初始化单个变量</span><br><span class="hljs-keyword">var</span> 变量名 变量类型 = 值<br><span class="hljs-comment">// 声明并初始化多个变量</span><br><span class="hljs-keyword">var</span> 变量名<span class="hljs-number">1</span>, 变量名<span class="hljs-number">2</span> 变量类型 = 值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>示例1，当只声明不初始化变量时，则输出默认值，int类型默认值为0，string默认值为””空字符串，bool类型默认false</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br>fmt.Println(s)<span class="hljs-comment">// 输出</span><br><span class="hljs-keyword">var</span> a, b <span class="hljs-type">int</span><br>fmt.Println(a, b)<span class="hljs-comment">// 输出0 0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例2：声明并初始化变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;hello world&quot;</span><br>fmt.Println(s)<span class="hljs-comment">// 输出hello world</span><br><span class="hljs-keyword">var</span> a, b <span class="hljs-type">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>fmt.Println(a, b)<span class="hljs-comment">// 输出1 2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用关键字var，不指定类型"><a href="#使用关键字var，不指定类型" class="headerlink" title="使用关键字var，不指定类型"></a>使用关键字var，不指定类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> 变量名 = 值<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;hello world&quot;</span><br>fmt.Println(s)<span class="hljs-comment">// 输出hello world</span><br><span class="hljs-keyword">var</span> a, b = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>fmt.Println(a, b)<span class="hljs-comment">// 输出1 2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用:="></a>使用<code>:=</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">变量名 := 值<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-string">&quot;hello world&quot;</span><br>fmt.Println(s)<span class="hljs-comment">// 输出hello world</span><br>a, b := <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>fmt.Println(a, b)<span class="hljs-comment">// 输出1 2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用该方法，如果某个变量在之前已经使用var的方式进行了声明，再使用<code>:=</code>方式会出现编译错误，但是可以使用<code>=</code>进行复制不会报错。</p><h3 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h3><p>该方法声明变量多用于声明全局变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span>(<br>    变量名<span class="hljs-number">1</span> 变量类型 = 值<span class="hljs-number">1</span><span class="hljs-comment">// 同样可以不指定变量类型，使用 变量名 = 值 的形式，但是不能使用 := </span><br>    变量名<span class="hljs-number">2</span> 变量类型 = 值<span class="hljs-number">2</span><br>)<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;hello world&quot;</span><br>a <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br>b <span class="hljs-type">int</span> = <span class="hljs-number">2</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(s)<span class="hljs-comment">// 输出hello world</span><br>fmt.Println(a, b)<span class="hljs-comment">// 输出1 2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="变量注意事项"><a href="#变量注意事项" class="headerlink" title="变量注意事项"></a>变量注意事项</h3><ol><li>在GO语言中，如果声明了一个变量，就必须使用，如果变量声明了但是不使用就会报错。</li><li>全局变量可以只声明不使用不会报错。</li></ol><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量就是不会改变的值，一般用于用于在程序运行期间不会被改变的值，常量和变量的声明类似，只是将<code>var</code>关键字变成了<code>const</code>。与变量不同的是，<strong>常量在声明的时候必须赋值。</strong></p><h3 id="使用const定义常量"><a href="#使用const定义常量" class="headerlink" title="使用const定义常量"></a>使用const定义常量</h3><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 多常量声明</span><br><span class="hljs-keyword">const</span> (<br>s = <span class="hljs-string">&quot;hello world&quot;</span><br>a = <span class="hljs-number">1</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.1415</span><span class="hljs-comment">// 不指定常量类型</span><br><span class="hljs-keyword">const</span> E <span class="hljs-type">float32</span> = <span class="hljs-number">2.7182</span><span class="hljs-comment">// 指定常量类型</span><br>fmt.Println(s)<span class="hljs-comment">// 输出hello world</span><br>fmt.Println(a)<span class="hljs-comment">// 输出1</span><br>fmt.Println(PI)<span class="hljs-comment">// 输出3.14</span><br>fmt.Println(E)<span class="hljs-comment">// 输出2.7182</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>iota是Go语言中的常量计数器，只能在常量的表达式中使用，iota在const出现时被初始化为0，在const中每增加一个常量定义，则iota加1。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 多常量声明</span><br><span class="hljs-keyword">const</span> (<br>a = <span class="hljs-number">1</span><span class="hljs-comment">// iota = 0</span><br>b = <span class="hljs-number">2</span><span class="hljs-comment">// iota = 1</span><br>c = <span class="hljs-literal">iota</span><span class="hljs-comment">// iota = 2</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> d = <span class="hljs-literal">iota</span><span class="hljs-comment">// iota = 0</span><br>fmt.Println(d)<span class="hljs-comment">// 输出0</span><br>fmt.Println(c)<span class="hljs-comment">// 输出2</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Go 语言变量名由字母、数字、下划线组成，首字符不能为数字，不能使用关键字作为变量名。</summary>
    
    
    
    <category term="Go语言入门" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Golang入门" scheme="http://example.com/tags/Golang%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Go语言入门01——环境安装</title>
    <link href="http://example.com/p/997792c1.html"/>
    <id>http://example.com/p/997792c1.html</id>
    <published>2024-09-03T11:04:23.000Z</published>
    <updated>2024-10-15T09:27:38.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="go语言开发包"><a href="#go语言开发包" class="headerlink" title="go语言开发包"></a>go语言开发包</h2><p>下载地址：<a href="https://go.dev/dl/">https://go.dev/dl/</a></p><p>进入官网选择对应的版本和系统下载并安装即可，官网有各个版本的安装包，如果是Windows可选择msi格式的安装文件进行安装，使用该格式可以不需要自己配置环境变量，安装完即可直接使用。（由于Go语言更新速度快，所以版本可能有所差距，直接安装最新版即可）</p><img src="/p/997792c1/1.png" class="" title="下载"><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>GoLand：<a href="https://www.jetbrains.com/go/">https://www.jetbrains.com/go/</a></p><p>GoLand为jetbrains公司针对Go语言的开发工具，该工具为收费工具，可下载后自行购买或使用学生优惠免费使用，同样可通过其他手段使用。</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>下载安装完成之后，点击打开即可选择New Project新建项目，在新建项目的时候Goland会自动搜索到本机已经安装的Go语言开发环境。</p><img src="/p/997792c1/2.png" class="" title="新建"><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>新建项目之后可在项目根目录下新建main.go文件，在文件中输入以下代码，运行即可打印出hello world，能正常打印则表示Go语言开发环境以及GoLand开发工具均安装配置成功。</p><img src="/p/997792c1/3.png" class="" title="helloWorld"><h2 id="Go基本语法"><a href="#Go基本语法" class="headerlink" title="Go基本语法"></a>Go基本语法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><ol><li><code>package main</code>：通过package关键字指定包名，在go文件中，必须要在代码一行指定当前文件属于哪个包名，包名可以自定义，但是一个go语言程序中必须有一个main包。</li><li><code>import &quot;fmt&quot;</code>：导入fmt包，导入之后在该文件中即可使用fmt包中的函数，fmt包中主要有格式化IO输入输出函数。</li><li><code>func main()</code>：main函数，一个go语言程序中必须包含一个main主函数，该函数是程序运行时执行的第一个函数（如果有init函数则第一个执行init函数）。</li><li><code>fmt.Println(&quot;hello world&quot;)</code>：调用fmt包中的打印函数Println，该函数可将其中的字符串打印到控制台上，并且在打印完成之后换行。</li></ol>]]></content>
    
    
    <summary type="html">Golang是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。</summary>
    
    
    
    <category term="Go语言入门" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Golang入门" scheme="http://example.com/tags/Golang%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Golang原子操作详解</title>
    <link href="http://example.com/p/a637193b.html"/>
    <id>http://example.com/p/a637193b.html</id>
    <published>2024-08-29T12:06:03.000Z</published>
    <updated>2024-10-15T09:27:38.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在日常开发中，不可避免的会碰到并发场景，在Go语言中处理同步的方法通常是使用锁，但如果是对单一的一个整数操作，这个时候使用锁可能会造成更大的性能开销，而且代码也失去了美观与优雅。<br>这个时候我们可以使用Go语言自带的原子操作，原子操作在Go语言的sync&#x2F;atomic标准库里面，原子操作是比其他同步技术更基础的一种技术，而且原子操作是无锁的，通常是直接通过CPU指令实现。如果去看其他同步技术的源码可以看到很多技术都是依赖于原子操作的。</p><h2 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h2><p>在正式介绍原子操作之前先看一段代码，该代码中创建了100000个协程，对一个公共变量x进行累加操作，总共有3个版本的代码，第一个版本是普通版，第二个版本是加锁版本，第三个版本是原子操作版本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>x    <span class="hljs-type">int64</span><br>lock sync.Mutex<br>wg   sync.WaitGroup<br>)<br><br><span class="hljs-comment">// 普通版</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br>x++<br>wg.Done()<br>&#125;<br><br><span class="hljs-comment">// 互斥锁版</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mutexAdd</span><span class="hljs-params">()</span></span> &#123;<br>lock.Lock()<br>x++<br>lock.Unlock()<br>wg.Done()<br>&#125;<br><br><span class="hljs-comment">// atomic版</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">atomicAdd</span><span class="hljs-params">()</span></span> &#123;<br>atomic.AddInt64(&amp;x, <span class="hljs-number">1</span>)<br>wg.Done()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>start := time.Now()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-comment">//go add() // 普通版add函数，非并发安全</span><br><span class="hljs-comment">//go mutexAdd() // 加锁版add函数，并发安全，但是加锁性能开销大</span><br><span class="hljs-keyword">go</span> atomicAdd() <span class="hljs-comment">// 原子操作版add函数，并发安全，性能优于加锁版</span><br>&#125;<br>wg.Wait()<br>end := time.Now()<br>fmt.Println(<span class="hljs-string">&quot;计算结果：&quot;</span>, x)<br>fmt.Println(<span class="hljs-string">&quot;消耗时间：&quot;</span>, end.Sub(start))<br>&#125;<br></code></pre></td></tr></table></figure><p>依次运行三个版本，得出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"># 普通版本<br>计算结果： <span class="hljs-number">96725</span><br>消耗时间： <span class="hljs-number">26.4237</span>ms<br><br># 加锁版本<br>计算结果： <span class="hljs-number">100000</span><br>消耗时间： <span class="hljs-number">31.2588</span>ms<br><br># 原子操作版本<br>计算结果： <span class="hljs-number">100000</span><br>消耗时间： <span class="hljs-number">27.3615</span>ms<br></code></pre></td></tr></table></figure><p>从上面的结果可以看出，普通版本的直接结算结果就是错误的，这个因为普通版本的不是并发安全的，所以会导致计算错误。加锁版本和原子操作版本都是计算正确，但是原子操作版本所消耗时间要比加锁版本更低（如果数字更大相差时间可能会更多，可以自行尝试）。</p><h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p>所有的原子操作都在atomic包下面，对于int32，int64，uint32，uint64，uintptr和Pointer类型，都有其对应的原子操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapInt32</span><span class="hljs-params">(addr *<span class="hljs-type">int32</span>, <span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>)</span></span> (old <span class="hljs-type">int32</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapInt64</span><span class="hljs-params">(addr *<span class="hljs-type">int64</span>, <span class="hljs-built_in">new</span> <span class="hljs-type">int64</span>)</span></span> (old <span class="hljs-type">int64</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapUint32</span><span class="hljs-params">(addr *<span class="hljs-type">uint32</span>, <span class="hljs-built_in">new</span> <span class="hljs-type">uint32</span>)</span></span> (old <span class="hljs-type">uint32</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapUint64</span><span class="hljs-params">(addr *<span class="hljs-type">uint64</span>, <span class="hljs-built_in">new</span> <span class="hljs-type">uint64</span>)</span></span> (old <span class="hljs-type">uint64</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapUintptr</span><span class="hljs-params">(addr *<span class="hljs-type">uintptr</span>, <span class="hljs-built_in">new</span> <span class="hljs-type">uintptr</span>)</span></span> (old <span class="hljs-type">uintptr</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapPointer</span><span class="hljs-params">(addr *unsafe.Pointer, <span class="hljs-built_in">new</span> unsafe.Pointer)</span></span> (old unsafe.Pointer)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapInt32</span><span class="hljs-params">(addr *<span class="hljs-type">int32</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>)</span></span> (swapped <span class="hljs-type">bool</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapInt64</span><span class="hljs-params">(addr *<span class="hljs-type">int64</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-type">int64</span>)</span></span> (swapped <span class="hljs-type">bool</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapUint32</span><span class="hljs-params">(addr *<span class="hljs-type">uint32</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-type">uint32</span>)</span></span> (swapped <span class="hljs-type">bool</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapUint64</span><span class="hljs-params">(addr *<span class="hljs-type">uint64</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-type">uint64</span>)</span></span> (swapped <span class="hljs-type">bool</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapUintptr</span><span class="hljs-params">(addr *<span class="hljs-type">uintptr</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-type">uintptr</span>)</span></span> (swapped <span class="hljs-type">bool</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapPointer</span><span class="hljs-params">(addr *unsafe.Pointer, old, <span class="hljs-built_in">new</span> unsafe.Pointer)</span></span> (swapped <span class="hljs-type">bool</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddInt32</span><span class="hljs-params">(addr *<span class="hljs-type">int32</span>, delta <span class="hljs-type">int32</span>)</span></span> (<span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddUint32</span><span class="hljs-params">(addr *<span class="hljs-type">uint32</span>, delta <span class="hljs-type">uint32</span>)</span></span> (<span class="hljs-built_in">new</span> <span class="hljs-type">uint32</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddInt64</span><span class="hljs-params">(addr *<span class="hljs-type">int64</span>, delta <span class="hljs-type">int64</span>)</span></span> (<span class="hljs-built_in">new</span> <span class="hljs-type">int64</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddUint64</span><span class="hljs-params">(addr *<span class="hljs-type">uint64</span>, delta <span class="hljs-type">uint64</span>)</span></span> (<span class="hljs-built_in">new</span> <span class="hljs-type">uint64</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddUintptr</span><span class="hljs-params">(addr *<span class="hljs-type">uintptr</span>, delta <span class="hljs-type">uintptr</span>)</span></span> (<span class="hljs-built_in">new</span> <span class="hljs-type">uintptr</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadInt32</span><span class="hljs-params">(addr *<span class="hljs-type">int32</span>)</span></span> (val <span class="hljs-type">int32</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadInt64</span><span class="hljs-params">(addr *<span class="hljs-type">int64</span>)</span></span> (val <span class="hljs-type">int64</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadUint32</span><span class="hljs-params">(addr *<span class="hljs-type">uint32</span>)</span></span> (val <span class="hljs-type">uint32</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadUint64</span><span class="hljs-params">(addr *<span class="hljs-type">uint64</span>)</span></span> (val <span class="hljs-type">uint64</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadUintptr</span><span class="hljs-params">(addr *<span class="hljs-type">uintptr</span>)</span></span> (val <span class="hljs-type">uintptr</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadPointer</span><span class="hljs-params">(addr *unsafe.Pointer)</span></span> (val unsafe.Pointer)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreInt32</span><span class="hljs-params">(addr *<span class="hljs-type">int32</span>, val <span class="hljs-type">int32</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreInt64</span><span class="hljs-params">(addr *<span class="hljs-type">int64</span>, val <span class="hljs-type">int64</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreUint32</span><span class="hljs-params">(addr *<span class="hljs-type">uint32</span>, val <span class="hljs-type">uint32</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreUint64</span><span class="hljs-params">(addr *<span class="hljs-type">uint64</span>, val <span class="hljs-type">uint64</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreUintptr</span><span class="hljs-params">(addr *<span class="hljs-type">uintptr</span>, val <span class="hljs-type">uintptr</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StorePointer</span><span class="hljs-params">(addr *unsafe.Pointer, val unsafe.Pointer)</span></span><br></code></pre></td></tr></table></figure><p>以上是atomic包中的所有方法，主要分为5种类型，下面根据不同类型逐一讲解。</p><h3 id="Load和Store"><a href="#Load和Store" class="headerlink" title="Load和Store"></a>Load和Store</h3><p>Load和Store方法主要用来在并发环境下实现对数字的设置和读取，Store表示给变量设置一个值，Load表示读取变量的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> value <span class="hljs-type">int64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>atomic.StoreInt64(&amp;value, <span class="hljs-number">1</span>)<br>val := atomic.LoadInt64(&amp;value)<br>fmt.Println(<span class="hljs-string">&quot;value: &quot;</span>, val)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>Add方法更简单，就是给一个变量加上一个值，使用Add方法加是并发安全的，不会出现上面示例中普通版本的add函数一样出现计算错误的问题。如果变量是有符号整数类型，需要实现对变量的减法，只需要调用Add方法的时候第二个参数传入负数即可。</p><h3 id="Swap和CompareAndSwap"><a href="#Swap和CompareAndSwap" class="headerlink" title="Swap和CompareAndSwap"></a>Swap和CompareAndSwap</h3><p>Swap是交换的意思，使用Swap方法可以修改变量的值，同时会将变量的旧值返回。<br>CompareAndSwap是比较并交换的意思，作用与Swap类似，也是修改变量的值，但是在调用CompareAndSwap的时候需要传入需要设置的新值和期望的旧值，如果当前变量的值和期望的旧值一样，才会将变量修改会新值，同时返回是否修改成功。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> value <span class="hljs-type">int64</span> = <span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>old := atomic.SwapInt64(&amp;value, <span class="hljs-number">2</span>)<br>fmt.Printf(<span class="hljs-string">&quot;旧值：%d, value：%d\n&quot;</span>, old, value)<br>swapped := atomic.CompareAndSwapInt64(&amp;value, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>fmt.Printf(<span class="hljs-string">&quot;修改结果：%t, value: %d\n&quot;</span>, swapped, value)<br>swapped = atomic.CompareAndSwapInt64(&amp;value, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>fmt.Printf(<span class="hljs-string">&quot;修改结果：%t, value: %d\n&quot;</span>, swapped, value)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的示例中将value设置为1，先使用Swap方法将Value修改为2，同时返回修改前的值。再使用CompareAndSwap想要修改为3，但是因为传入的期望值1和value的实际值2不相等，所以修改失败，再次调用期望值为2且value的实际值为2，则修改成功。运行结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">旧值：<span class="hljs-number">1</span>, value：<span class="hljs-number">2</span><br>修改结果：<span class="hljs-literal">false</span>, value: <span class="hljs-number">2</span><br>修改结果：<span class="hljs-literal">true</span>, value: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="新版本结构体类型"><a href="#新版本结构体类型" class="headerlink" title="新版本结构体类型"></a>新版本结构体类型</h2><p>在1.19版本，Go语言在atomic中新增了Int32，Int64等结构体类型，使用结构体类型进行原子操作更简单，不需要再想之前一样每次从atomic中调用各种类型的方法来实现原子操作。而是只需要使用结构体的方法即可直接进行原子操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> value atomic.Int64<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>value.Store(<span class="hljs-number">1</span>)<br>fmt.Println(<span class="hljs-string">&quot;value: &quot;</span>, value.Load())<br>n := value.Add(<span class="hljs-number">1</span>)<br>fmt.Println(<span class="hljs-string">&quot;value: &quot;</span>, n)<br>old := value.Swap(<span class="hljs-number">3</span>)<br>fmt.Printf(<span class="hljs-string">&quot;旧值：%d, value：%d\n&quot;</span>, old, value.Load())<br>swapped := value.CompareAndSwap(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>fmt.Printf(<span class="hljs-string">&quot;修改结果：%t, value：%d\n&quot;</span>, swapped, value.Load())<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中使用的就是最新的写法结构体类型，运行结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">value:  <span class="hljs-number">1</span><br>value:  <span class="hljs-number">2</span>               <br>旧值：<span class="hljs-number">2</span>, value：<span class="hljs-number">3</span>       <br>修改结果：<span class="hljs-literal">true</span>, value：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">原子操作是解决同步问题的基础技术。</summary>
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Golang进阶" scheme="http://example.com/tags/Golang%E8%BF%9B%E9%98%B6/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令详解</title>
    <link href="http://example.com/p/62a12d8b.html"/>
    <id>http://example.com/p/62a12d8b.html</id>
    <published>2024-08-26T11:26:26.000Z</published>
    <updated>2024-10-15T09:27:38.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="启动类命令"><a href="#启动类命令" class="headerlink" title="启动类命令"></a>启动类命令</h2><p>启动docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start docker<br></code></pre></td></tr></table></figure><p>停止Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl stop docker<br></code></pre></td></tr></table></figure><p>重启Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart docker<br></code></pre></td></tr></table></figure><p>查看状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status docker<br></code></pre></td></tr></table></figure><p>设置开机自启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure><h2 id="帮助类命令"><a href="#帮助类命令" class="headerlink" title="帮助类命令"></a>帮助类命令</h2><p>查看Docker版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker version<br></code></pre></td></tr></table></figure><p>查看Docker概要信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker info<br></code></pre></td></tr></table></figure><p>查看Docker总体帮助文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>查看docker具体命令帮助文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker 具体命令 --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><h3 id="列出本地主机上的镜像"><a href="#列出本地主机上的镜像" class="headerlink" title="列出本地主机上的镜像"></a>列出本地主机上的镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li><code>a</code>：列出所有镜像（含历史镜像）</li><li><code>q</code>：只显示镜像ID</li><li><code>f</code>：过滤</li></ul><h3 id="在远程仓库中搜索镜像"><a href="#在远程仓库中搜索镜像" class="headerlink" title="在远程仓库中搜索镜像"></a>在远程仓库中搜索镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 默认取docker hub中搜索</span><br>docker search 镜像名称<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li><code>f</code>：过滤</li><li><code>-limit 数量</code>：只展示前几项</li></ul><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull 镜像名称[:tag]<br></code></pre></td></tr></table></figure><p>不加 tag 时，默认下载最新的镜像（即tag为<code>latest</code>）。</p><h3 id="查看占据的空间"><a href="#查看占据的空间" class="headerlink" title="查看占据的空间"></a>查看占据的空间</h3><p>查看镜像&#x2F;容器&#x2F;数据卷所占的空间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker system <span class="hljs-built_in">df</span><br></code></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi 镜像名称/ID<br></code></pre></td></tr></table></figure><p>可以使用空格分隔，删除多个镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi 镜像1 镜像2 镜像3<br></code></pre></td></tr></table></figure><p>删除全部镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi -f <span class="hljs-variable">$&#123;docker images -qa&#125;</span><br></code></pre></td></tr></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a><strong>容器命令</strong></h2><h3 id="新建启动容器"><a href="#新建启动容器" class="headerlink" title="新建启动容器"></a>新建启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure><p>常用的参数：</p><ul><li><code>-name</code>：为容器指定一个名称</li><li><code>d</code>：后台运行容器并返回容器ID，也即启动守护式容器</li><li><code>i</code>：以交互模式（interactive）运行容器，通常与<code>t</code>同时使用</li><li><code>t</code>：为容器重新分配一个伪输入终端（tty），通常与<code>i</code>同时使用。也即启动交互式容器（前台有伪终端，等待交互）</li><li><code>e</code>：为容器添加环境变量</li><li><code>P</code>：随机端口映射。将容器内暴露的所有端口映射到宿主机随机端口</li><li><code>p</code>：指定端口映射</li><li><code>p</code>指定端口映射的几种不同形式：</li><li><code>p hostPort:containerPort</code>：端口映射，例如<code>p 8080:80</code></li><li><code>p ip:hostPort:containerPort</code>：配置监听地址，例如 <code>p 10.0.0.1:8080:80</code></li><li><code>p ip::containerPort</code>：随机分配端口，例如 <code>p 10.0.0.1::80</code></li><li><code>p hostPort1:containerPort1 -p hostPort2:containerPort2</code>：指定多个端口映射，例如<code>p 8080:80 -p 8888:3306</code></li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name nginx001 -p 80:8080 -d nginx<br></code></pre></td></tr></table></figure><h3 id="启动交互式容器"><a href="#启动交互式容器" class="headerlink" title="启动交互式容器"></a>启动交互式容器</h3><p>以交互方式启动ubuntu镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -i 交互模式</span><br><span class="hljs-comment"># -t 分配一个伪输入终端tty</span><br><span class="hljs-comment"># ubuntu 镜像名称</span><br><span class="hljs-comment"># /bin/bash（或者bash） shell交互的接口</span><br>docker run -it ubuntu /bin/bash<br></code></pre></td></tr></table></figure><p>退出交互模式：<br>方式1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在交互shell中exit即可退回宿主机</span><br><span class="hljs-built_in">exit</span>;<br></code></pre></td></tr></table></figure><p>方式2：使用快捷键<code>ctrl</code> + <code>P</code> + <code>Q</code><br>方式1 退出后，容器会停止；<br>方式2 退出后容器依然正在运行。</p><h3 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h3><p>大部分情况下，我们系统docker容器服务时在后台运行的，可以通过<code>-d</code>指定容器的后台运行模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d 容器名<br></code></pre></td></tr></table></figure><p>注意事项：<br>如果使用<code>docker run -d ubuntu</code>尝试启动守护式的ubuntu，会发现容器启动后就自动退出了。<br>因为Docker容器如果在后台运行，就必须要有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（例如<code>top</code>、<code>tail</code>），就会自动退出。</p><h3 id="列出正在运行的容器"><a href="#列出正在运行的容器" class="headerlink" title="列出正在运行的容器"></a>列出正在运行的容器</h3><p>列出所有正在运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps [OPTIONS]<br></code></pre></td></tr></table></figure><p>常用参数：</p><ul><li><code>a</code>：列出当前所有正在运行的容器+历史上运行过的容器</li><li><code>l</code>：显示最近创建的容器</li><li><code>n</code>：显示最近n个创建的容器</li><li><code>q</code>：静默模式，只显示容器编号</li></ul><h3 id="启动已经停止的容器"><a href="#启动已经停止的容器" class="headerlink" title="启动已经停止的容器"></a>启动已经停止的容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker start 容器ID或容器名<br></code></pre></td></tr></table></figure><h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker restart 容器ID或容器名<br></code></pre></td></tr></table></figure><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker stop 容器ID或容器名<br></code></pre></td></tr></table></figure><h3 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> 容器ID或容器名<br></code></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>删除已经停止的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> 容器ID或容器名<br></code></pre></td></tr></table></figure><blockquote><p>删除容器是 docker rm，删除镜像是 docker rmi，注意区分。</p></blockquote><p>强制删除正在运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> -f 容器ID或容器名<br></code></pre></td></tr></table></figure><h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><p>列出docker中的虚悬镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker image <span class="hljs-built_in">ls</span> -f dangling=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>虚悬镜像一般是因为一些错误而出现的，没有存在价值，可以删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除所有的虚悬镜像</span><br>docker image prune<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Docker常用命令详解</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Go语言time包基础使用</title>
    <link href="http://example.com/p/ce34811b.html"/>
    <id>http://example.com/p/ce34811b.html</id>
    <published>2024-08-23T11:16:36.000Z</published>
    <updated>2024-10-15T09:27:38.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="time包"><a href="#time包" class="headerlink" title="time包"></a>time包</h2><p>Go语言中有关于时间和日期的方法都在time包里面，Go语言的time包为开发者提供了一套全面而简洁的工具来处理时间相关的操作。包括解析和格式化时间字符串，计算时间差和时区转换等，time包时Go语言中处理时间和日期的核心组件。</p><h2 id="时间类型（Time）"><a href="#时间类型（Time）" class="headerlink" title="时间类型（Time）"></a>时间类型（Time）</h2><p>time包中的Time结构体表示的是时间类型，在Go语言中，我们可以使用time.Now()方法来获取当前的时间，该方法返回的就是Time类型，调用Time类型的方法就可以分别获取到当前时间的年月日时分秒等信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br><br>fmt.Println(now) <span class="hljs-comment">// 2024-07-23 19:36:03.4481196 +0800 CST m=+0.004232101</span><br><br>fmt.Println(now.Year())   <span class="hljs-comment">// 2024</span><br>fmt.Println(now.Month())  <span class="hljs-comment">// July</span><br>fmt.Println(now.Day())    <span class="hljs-comment">// 23</span><br>fmt.Println(now.Hour())   <span class="hljs-comment">// 19</span><br>fmt.Println(now.Minute()) <span class="hljs-comment">// 36</span><br>fmt.Println(now.Second()) <span class="hljs-comment">// 3</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h2><p>从上面的输出可以看到当前日期的输出后面还携带了有其他的消息，不是我们常用的格式，这个时候就可以使用Go语言的时间格式化功能，使用format方法并执行格式化模板，Go语言的格式化模版并不是常用的Y-m-d H:M:S，而是2006-01-02 15:04:05，记忆方法：200612345（相传这个时间为Go语言诞生时间，不知真假）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br>fmt.Println(now.Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>))    <span class="hljs-comment">// 2024-07-23 19:37:58</span><br>fmt.Println(now.Format(<span class="hljs-string">&quot;2006-01-02 03:04:05 PM&quot;</span>)) <span class="hljs-comment">// 2024-07-23 07:41:20 PM</span><br>fmt.Println(now.Format(<span class="hljs-string">&quot;2006/01/02 15:04&quot;</span>))       <span class="hljs-comment">// 2024/07/23 19:40</span><br>fmt.Println(now.Format(<span class="hljs-string">&quot;15:04 2006/01/02&quot;</span>))       <span class="hljs-comment">// 19:40 2024/07/23</span><br>fmt.Println(now.Format(<span class="hljs-string">&quot;2006/01/02&quot;</span>))             <span class="hljs-comment">// 2024/07/23</span><br>&#125;<br></code></pre></td></tr></table></figure><p>除了自己写格式化模版之外，Go语言已经内置了一部分模版可供选择，模版在format包里面，可以直接使用，源码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>Layout      = <span class="hljs-string">&quot;01/02 03:04:05PM &#x27;06 -0700&quot;</span> <span class="hljs-comment">// The reference time, in numerical order.</span><br>ANSIC       = <span class="hljs-string">&quot;Mon Jan _2 15:04:05 2006&quot;</span><br>UnixDate    = <span class="hljs-string">&quot;Mon Jan _2 15:04:05 MST 2006&quot;</span><br>RubyDate    = <span class="hljs-string">&quot;Mon Jan 02 15:04:05 -0700 2006&quot;</span><br>RFC822      = <span class="hljs-string">&quot;02 Jan 06 15:04 MST&quot;</span><br>RFC822Z     = <span class="hljs-string">&quot;02 Jan 06 15:04 -0700&quot;</span> <span class="hljs-comment">// RFC822 with numeric zone</span><br>RFC850      = <span class="hljs-string">&quot;Monday, 02-Jan-06 15:04:05 MST&quot;</span><br>RFC1123     = <span class="hljs-string">&quot;Mon, 02 Jan 2006 15:04:05 MST&quot;</span><br>RFC1123Z    = <span class="hljs-string">&quot;Mon, 02 Jan 2006 15:04:05 -0700&quot;</span> <span class="hljs-comment">// RFC1123 with numeric zone</span><br>RFC3339     = <span class="hljs-string">&quot;2006-01-02T15:04:05Z07:00&quot;</span><br>RFC3339Nano = <span class="hljs-string">&quot;2006-01-02T15:04:05.999999999Z07:00&quot;</span><br>Kitchen     = <span class="hljs-string">&quot;3:04PM&quot;</span><br><span class="hljs-comment">// Handy time stamps.</span><br>Stamp      = <span class="hljs-string">&quot;Jan _2 15:04:05&quot;</span><br>StampMilli = <span class="hljs-string">&quot;Jan _2 15:04:05.000&quot;</span><br>StampMicro = <span class="hljs-string">&quot;Jan _2 15:04:05.000000&quot;</span><br>StampNano  = <span class="hljs-string">&quot;Jan _2 15:04:05.000000000&quot;</span><br>DateTime   = <span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span><br>DateOnly   = <span class="hljs-string">&quot;2006-01-02&quot;</span><br>TimeOnly   = <span class="hljs-string">&quot;15:04:05&quot;</span><br>)<br></code></pre></td></tr></table></figure><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>时间戳是自1970年1月1日（08:00:00GMT）至当前时间的总毫秒数，也被称为Unix时间戳，在Go语言里面，可以获取四种级别的时间戳，分别是秒、毫秒、微秒和纳秒。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br>fmt.Println(now.Unix())      <span class="hljs-comment">// 1721735188</span><br>fmt.Println(now.UnixMilli()) <span class="hljs-comment">// 1721735188504</span><br>fmt.Println(now.UnixMicro()) <span class="hljs-comment">// 1721735188504566</span><br>fmt.Println(now.UnixNano())  <span class="hljs-comment">// 1721735188504566800</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间间隔"><a href="#时间间隔" class="headerlink" title="时间间隔"></a>时间间隔</h2><p>在time包里面还定义了一个Duration类型，Duration表示时间间隔，例如可以直接使用time.Second表示1秒，time.Hour * 3表示3个小时，Duration源码定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>Nanosecond  Duration = <span class="hljs-number">1</span><br>Microsecond          = <span class="hljs-number">1000</span> * Nanosecond<br>Millisecond          = <span class="hljs-number">1000</span> * Microsecond<br>Second               = <span class="hljs-number">1000</span> * Millisecond<br>Minute               = <span class="hljs-number">60</span> * Second<br>Hour                 = <span class="hljs-number">60</span> * Minute<br>)<br></code></pre></td></tr></table></figure><h2 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h2><p>在Go语言里面还可以非常简单的进行时间的比较以及计算</p><h3 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h3><p>可以使用Add方法在当前时间的基础上加上指定的时间间隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br>fmt.Println(now)                    <span class="hljs-comment">// 2024-07-23 19:52:14.0840934 +0800 CST m=+0.004981601</span><br>fmt.Println(now.Add(time.Hour * <span class="hljs-number">2</span>)) <span class="hljs-comment">// 2024-07-23 21:52:14.0840934 +0800 CST m=+7200.004981601</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="时间间隔-1"><a href="#时间间隔-1" class="headerlink" title="时间间隔"></a>时间间隔</h3><p>还可以使用Sub方法计算两个时间之间相隔了多长时间，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br>fmt.Println(now.Sub(now.Add(time.Hour * <span class="hljs-number">-2</span>))) <span class="hljs-comment">// 2h0m0s</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="之前"><a href="#之前" class="headerlink" title="之前"></a>之前</h3><p>使用Before判断一个时间是否在另一个时间之前</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br>fmt.Println(now.Before(now.Add(time.Hour))) <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="之后"><a href="#之后" class="headerlink" title="之后"></a>之后</h3><p>使用After判断一个时间是否在另一个时间之后</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br>fmt.Println(now.After(now.Add(time.Hour))) <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h3><p>使用Equal判断两个时间是否相同</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br>fmt.Println(now.Equal(now.Add(time.Hour))) <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h2><h3 id="字符串转时间"><a href="#字符串转时间" class="headerlink" title="字符串转时间"></a>字符串转时间</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>timeStr := <span class="hljs-string">&quot;2024-07-23 12:23:34&quot;</span><br>time1, _ := time.Parse(time.DateTime, timeStr)<br>fmt.Println(time1) <span class="hljs-comment">// 2024-07-23 12:23:34 +0000 UTC</span><br>time2, _ := time.ParseInLocation(time.DateTime, timeStr, time.Local)<br>fmt.Println(time2) <span class="hljs-comment">// 2024-07-23 12:23:34 +0800 CST</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用Parse和ParseInLocation将字符串时间转成Time类型的时间，两者的区别如下：</p><ul><li><code>time.Parse</code> 总是将时间解析为 UTC 时区</li><li><code>time.ParseInLocation</code> 允许指定一个时区解析</li></ul><h3 id="时间戳转时间"><a href="#时间戳转时间" class="headerlink" title="时间戳转时间"></a>时间戳转时间</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>time1 := time.Unix(<span class="hljs-number">1721735188</span>, <span class="hljs-number">0</span>)<br>time2 := time.UnixMilli(<span class="hljs-number">1721735188504</span>)<br>time3 := time.UnixMicro(<span class="hljs-number">1721735188504566</span>)<br>fmt.Println(time1) <span class="hljs-comment">// 2024-07-23 19:46:28 +0800 CST</span><br>fmt.Println(time2) <span class="hljs-comment">// 2024-07-23 19:46:28.504 +0800 CST</span><br>fmt.Println(time3) <span class="hljs-comment">// 2024-07-23 19:46:28.504566 +0800 CST</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用time包的Unix、UnixMilli和UnixMicro可以分别将秒、毫秒、微秒级别的时间戳转成相应的Time类型的时间。</p>]]></content>
    
    
    <summary type="html">Go语言中有关于时间和日期的方法都在time包里面，Go语言的time包为开发者提供了一套全面而简洁的工具来处理时间相关的操作。包括解析和格式化时间字符串，计算时间差和时区转换等，time包时Go语言中处理时间和日期的核心组件。</summary>
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
    <category term="时间格式化" scheme="http://example.com/tags/%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Go语言Context如何使用</title>
    <link href="http://example.com/p/5226b0cc.html"/>
    <id>http://example.com/p/5226b0cc.html</id>
    <published>2024-08-19T10:57:14.000Z</published>
    <updated>2024-10-15T09:27:38.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go语言Context如何使用"><a href="#Go语言Context如何使用" class="headerlink" title="Go语言Context如何使用"></a>Go语言Context如何使用</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>相信大家在日常使用Go语言进行开发的时候一定会遇到下面这种代码，特别是在Web开发中使用了诸如Gin、Echo和Beego类似的开发框架。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getUser</span><span class="hljs-params">(ctx context.Context, id <span class="hljs-type">int64</span>)</span></span>&#123;<br>  getUserById(ctx, id)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getUserById</span><span class="hljs-params">(ctx context.Context, id <span class="hljs-type">int64</span>)</span></span>&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>能够从上面的代码中看出，每个方法的第一个参数都是<code>Context</code>。<br><code>Context</code>是Go语言在1.7版本引入的，<code>Context</code>可以用来在<code>goroutine</code>之间传递上下文信息，通常可以用来进行超时控制，消息传递等，Go语言官方建议的将<code>Context</code>作为函数的第一个参数并不断地透传下去以实现在不同的<code>goroutine</code>之间传递上下文。</p><h2 id="Context的使用"><a href="#Context的使用" class="headerlink" title="Context的使用"></a>Context的使用</h2><p><code>context</code>包中提供了两种方式创建<code>Context</code>：</p><ul><li><code>context.Backgroud()</code></li><li><code>context.TODO()</code></li></ul><p>通过这两种方式都可以创建一个<code>Context</code>，而且两者之间没有区别，官方给出的定义是：</p><ul><li><code>context.Background</code> 是上下文的默认值，所有其他的上下文都应该从它衍生（Derived）出来；</li><li><code>context.TODO</code> 应该只在不确定应该使用哪种上下文时使用；</li></ul><p>使用这两种方法创建出来的<code>Context</code>都是默认的<code>Context</code>，也可以称为父<code>Context</code>，不具备我们上面说到的消息传递，超时控制这些功能，需要实现这些功能就需要使用<code>context</code>包提供的另外几个创建<code>Context</code>的方法：</p><ul><li><code>context.WithCancel(parent Context)</code></li><li><code>context.WithDeadline(parent Context, deadline time.Time)</code></li><li><code>context.WithTimeout(parent Context, timeout time.Duration)</code></li><li><code>context.WithValue(parent Context, key, val interface&#123;&#125;)</code></li></ul><h2 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h2><p>在日常的开发中，日志是必不可少的一部分，同时我们都希望在日志打印的时候能够携带一个<code>tranceID</code>，这样的话根据一个<code>tranceID</code>就可以关联出一个请求的所有日志，这个在Go语言中就可以使用<code>Context</code>的传递数据方式实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> Key = <span class="hljs-string">&quot;trance_id&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx := context.WithValue(context.Background(), Key, <span class="hljs-string">&quot;1001&quot;</span>)<br>router(ctx)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">router</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>printLog(ctx, <span class="hljs-string">&quot;router方法的日志&quot;</span>)<br>service(ctx)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">service</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>printLog(ctx, <span class="hljs-string">&quot;service方法的日志&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printLog</span><span class="hljs-params">(ctx context.Context, msg <span class="hljs-type">string</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s | level=info | trance_id=%s | message=%s\n&quot;</span>, time.Now().Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>), ctx.Value(Key), msg)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中通过<code>WithValue</code>方法创建了一个可以携带数据的<code>Context</code>，然后在方法调用链中将<code>Context</code>作为第一个参数一直传递，在每个方法中都可以通过<code>Value</code>取到最开始放进去的<code>tranceID</code>，最后打印结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">2024</span><span class="hljs-number">-07</span><span class="hljs-number">-18</span> <span class="hljs-number">19</span>:<span class="hljs-number">44</span>:<span class="hljs-number">24</span> | level=info | trance_id=<span class="hljs-number">1001</span> | message=router方法的日志<br><span class="hljs-number">2024</span><span class="hljs-number">-07</span><span class="hljs-number">-18</span> <span class="hljs-number">19</span>:<span class="hljs-number">44</span>:<span class="hljs-number">24</span> | level=info | trance_id=<span class="hljs-number">1001</span> | message=service方法的日志<br></code></pre></td></tr></table></figure><h2 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h2><p>要使用<code>Context</code>实现超时控制可以使用<code>WithTimeout</code>或<code>WithDeadline</code>，通过这两个方法创建出来的<code>Context</code>都可以实现超时控制，两个方法的作用是一样的。同时两个方法都会返回一个<code>cancel</code>方法，通过调用这个方法可以提前取消，不需要等到传入的时间达到即可取消。<br>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancelFunc := context.WithTimeout(context.Background(), <span class="hljs-number">3</span>*time.Second)<br><span class="hljs-keyword">defer</span> cancelFunc()<br>test(ctx)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(ctx.Err())<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;test = %d\n&quot;</span>, i)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中通过<code>WithTimeout</code>创建了一个时间为<code>3</code>秒的<code>Context</code>，然后在<code>test</code>方法中进行循环，每隔<code>1</code>秒输出一个<code>test</code>语句，但是由于<code>Context</code>的超时设置的<code>3</code>秒，所以当<code>3</code>秒后<code>Context</code>就会自动取消，最后<code>test</code>的输出也就只有2行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">test = <span class="hljs-number">0</span><br>test = <span class="hljs-number">1</span><br>context deadline exceeded<br></code></pre></td></tr></table></figure><h2 id="WithCancel取消控制"><a href="#WithCancel取消控制" class="headerlink" title="WithCancel取消控制"></a>WithCancel取消控制</h2><p>在开发中有时候可能需要同时创建多个<code>goroutine</code>并行的去进行一些逻辑的处理，但是当主<code>goroutine</code>出现错误的时候，这时候我们就已经不需要其他的<code>goroutine</code>继续执行，这种情况我们就可以使用<code>WithCancel</code>创建一个可以取消的<code>Context</code>，将<code>Context</code>传入到不同的<code>goroutine</code>中，当主<code>goroutine</code>出错时，直接调用<code>cancel</code>方法就可以取消所有的<code>goroutine</code>。<br>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancelFunc := context.WithCancel(context.Background())<br><span class="hljs-keyword">go</span> test(ctx)<br>time.Sleep(<span class="hljs-number">3</span> * time.Second)<br>cancelFunc()<br>time.Sleep(time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;取消执行&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;test = %d\n&quot;</span>, i)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码通过<code>WithCancel</code>创建了一个可以取消的<code>Context</code>，然后创建了一个<code>goroutine</code>执行<code>test</code>方法，当主<code>goroutine</code>等待3秒后调用<code>cancel</code>方法取消，这时候执行<code>test</code>方法的<code>goroutine</code>就会直接退出不再执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">test = <span class="hljs-number">0</span><br>test = <span class="hljs-number">1</span><br>取消执行<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Context是Go语言在1.7版本引入的，Context可以用来在goroutine之间传递上下文信息，通常可以用来进行超时控制，消息传递等，Go语言官方建议的将Context作为函数的第一个参数并不断地透传下去以实现在不同的goroutine之间传递上下文。</summary>
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Golang进阶" scheme="http://example.com/tags/Golang%E8%BF%9B%E9%98%B6/"/>
    
    <category term="上下文" scheme="http://example.com/tags/%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Go语言定时器的使用</title>
    <link href="http://example.com/p/df47ea8c.html"/>
    <id>http://example.com/p/df47ea8c.html</id>
    <published>2024-08-18T07:46:04.000Z</published>
    <updated>2024-10-15T09:27:38.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在日常开发中，我们不可避免的需要使用到定时任务用来处理业务逻辑。在Go语言中内置的有两个定时器，<code>Timer</code>和<code>Ticker</code>，合理的使用这两个定时器可以很好的解决定时任务的需求，同时除了这两个内置的定时器外，还有另外的三方库也可以用来完成定时任务的需求。</p><h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Timer</code>定时器可以在指定时间后执行一次，使用<code>time</code>包中的<code>NewTimer</code>方法传入间隔时间参数即可创建一个<code>Timer</code>定时器，定时器将会在指定的时间后执行一次。<br><code>Timer</code>中共有以下方法可调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTimer</span><span class="hljs-params">(d Duration)</span></span> *Timer<br><span class="hljs-comment">// 重置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Timer)</span></span> Reset(d Duration) <span class="hljs-type">bool</span><br><span class="hljs-comment">// 停止</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Timer)</span></span> Stop() <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><p>在<code>Timer</code>中除了有以上方法之外，还有最重要的就是<code>Timer</code>中包含一个时间类型的通道<code>C</code>，当指定时间间隔到达后，就会将当前时间发送到通道<code>C</code>中，这样我们可以使用<code>select</code>监听通道<code>C</code>即可完成在指定时间后执行任务的需求。</p><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>我们根据上面的描述，完成了下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个Timer定时器</span><br>    timer := time.NewTimer(time.Second * <span class="hljs-number">2</span>)<br>    <span class="hljs-comment">// 延迟关闭定时器</span><br>    <span class="hljs-keyword">defer</span> timer.Stop()<br>    fmt.Println(<span class="hljs-string">&quot;当前时间：&quot;</span>, time.Now())<br>    <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-comment">// 使用select监听通道C</span><br>        <span class="hljs-keyword">case</span> nowTime := &lt;-timer.C:<br>        fmt.Println(<span class="hljs-string">&quot;间隔2秒后指定定时任务，当前时间：&quot;</span>, nowTime)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在idea中运行代码后会输出以下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">当前时间： <span class="hljs-number">2024</span><span class="hljs-number">-06</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">12</span>:<span class="hljs-number">08.7736065</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">0.002108801</span><br>间隔<span class="hljs-number">2</span>秒后指定定时任务，当前时间： <span class="hljs-number">2024</span><span class="hljs-number">-06</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">12</span>:<span class="hljs-number">10.7797079</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">2.008210201</span><br><br>Process finished with the exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>Timer</code>定时器在指定时间后会执行一次任务，然后结束。</p><h3 id="Reset使用"><a href="#Reset使用" class="headerlink" title="Reset使用"></a>Reset使用</h3><p>在上面的代码中可以看到<code>Timer</code>在指定时间后仅能执行一次任务，但是我们可以使用<code>Reset</code>方法重置定时器，这样的话可以在每次执行任务后重置，用来达到每间隔指定时间都执行一次任务的需求。<br>将代码略做修改如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建一个Timer定时器</span><br>timer := time.NewTimer(time.Second * <span class="hljs-number">2</span>)<br><span class="hljs-comment">// 延迟关闭定时器</span><br><span class="hljs-keyword">defer</span> timer.Stop()<br>fmt.Println(<span class="hljs-string">&quot;当前时间：&quot;</span>, time.Now())<br><span class="hljs-keyword">for</span> &#123;<br>timer.Reset(time.Second * <span class="hljs-number">2</span>)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-comment">// 使用select监听通道C</span><br><span class="hljs-keyword">case</span> nowTime := &lt;-timer.C:<br>fmt.Println(<span class="hljs-string">&quot;间隔2秒后指定定时任务，当前时间：&quot;</span>, nowTime)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面代码中可以看到在每次的循环中都重置一次<code>Timer</code>定时器，这样的话就可以实现每隔一段时间都执行一次任务的需求。<br>最终运行结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">当前时间： <span class="hljs-number">2024</span><span class="hljs-number">-06</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">01.2907834</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">0.002052801</span><br>间隔<span class="hljs-number">2</span>秒后指定定时任务，当前时间： <span class="hljs-number">2024</span><span class="hljs-number">-06</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">03.3096846</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">2.020954001</span><br>间隔<span class="hljs-number">2</span>秒后指定定时任务，当前时间： <span class="hljs-number">2024</span><span class="hljs-number">-06</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">05.3236498</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">4.034919201</span><br>间隔<span class="hljs-number">2</span>秒后指定定时任务，当前时间： <span class="hljs-number">2024</span><span class="hljs-number">-06</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">07.3318153</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">6.043084701</span><br>间隔<span class="hljs-number">2</span>秒后指定定时任务，当前时间： <span class="hljs-number">2024</span><span class="hljs-number">-06</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">09.3462966</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">8.057566001</span><br>间隔<span class="hljs-number">2</span>秒后指定定时任务，当前时间： <span class="hljs-number">2024</span><span class="hljs-number">-06</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">11.3504773</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">10.061746701</span><br>……<br></code></pre></td></tr></table></figure><h1 id="Ticker"><a href="#Ticker" class="headerlink" title="Ticker"></a>Ticker</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><code>Ticker</code>定时器的用法和<code>Timer</code>定时器的用法以及内置的方法都一样，区别在于<code>Ticker</code>不仅仅只执行一次，而是会根据指定的时间间隔不停地执行。</p><h2 id="基础用法-1"><a href="#基础用法-1" class="headerlink" title="基础用法"></a>基础用法</h2><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ticker := time.NewTicker(time.Second * <span class="hljs-number">2</span>)<br><span class="hljs-keyword">defer</span> ticker.Stop()<br>fmt.Println(<span class="hljs-string">&quot;当前时间：&quot;</span>, time.Now())<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> nowTime := &lt;-ticker.C:<br>fmt.Println(<span class="hljs-string">&quot;间隔2秒后指定定时任务，当前时间：&quot;</span>, nowTime)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据<code>Ticker</code>写出以上代码，代码会每隔<code>2</code>秒执行一次，不需要像<code>Timer</code>中那样每次使用<code>Reset</code>方法来重置定时器，最终运行结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">当前时间： <span class="hljs-number">2024</span><span class="hljs-number">-06</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">20</span>:<span class="hljs-number">27.4070592</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">0.002137901</span><br>间隔<span class="hljs-number">2</span>秒后指定定时任务，当前时间： <span class="hljs-number">2024</span><span class="hljs-number">-06</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">20</span>:<span class="hljs-number">29.4083801</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">2.003458801</span><br>间隔<span class="hljs-number">2</span>秒后指定定时任务，当前时间： <span class="hljs-number">2024</span><span class="hljs-number">-06</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">20</span>:<span class="hljs-number">31.414517</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">4.009595701</span><br>间隔<span class="hljs-number">2</span>秒后指定定时任务，当前时间： <span class="hljs-number">2024</span><span class="hljs-number">-06</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">20</span>:<span class="hljs-number">33.4191099</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">6.014188601</span><br>间隔<span class="hljs-number">2</span>秒后指定定时任务，当前时间： <span class="hljs-number">2024</span><span class="hljs-number">-06</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">20</span>:<span class="hljs-number">35.4099723</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">8.005051001</span><br>间隔<span class="hljs-number">2</span>秒后指定定时任务，当前时间： <span class="hljs-number">2024</span><span class="hljs-number">-06</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">20</span>:<span class="hljs-number">37.4208446</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">10.015923301</span><br>……<br></code></pre></td></tr></table></figure><p>在<code>Ticker</code>定时器中同样也有<code>Reset</code>方法，但是就算不调用<code>Reset</code>方法定时器也会一直执行，所以这里的<code>Reset</code>方法可以用来重置定时器的间隔时间。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul><li><code>Ticker</code>定时器表示每隔一段时间就执行一次，一般可执行多次。</li><li><code>Timer</code>定时器表示在一段时间后执行，默认情况下只执行一次，如果想再次执行的话，每次都需要调用<code>Reset</code>方法，此时效果类似<code>Ticker</code>定时器。同时也可以调用<code>Stop</code>方法取消定时器。</li></ul>]]></content>
    
    
    <summary type="html">在日常开发中，我们不可避免的需要使用到定时任务用来处理业务逻辑。在Go语言中内置的有两个定时器，Timer和Ticker，合理的使用这两个定时器可以很好的解决定时任务的需求。</summary>
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Golang进阶" scheme="http://example.com/tags/Golang%E8%BF%9B%E9%98%B6/"/>
    
    <category term="定时任务" scheme="http://example.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Go语言反射</title>
    <link href="http://example.com/p/17939c02.html"/>
    <id>http://example.com/p/17939c02.html</id>
    <published>2024-08-15T11:55:39.000Z</published>
    <updated>2024-10-15T09:27:38.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go语言反射技术解析"><a href="#Go语言反射技术解析" class="headerlink" title="Go语言反射技术解析"></a>Go语言反射技术解析</h1><h2 id="1-什么是反射"><a href="#1-什么是反射" class="headerlink" title="1. 什么是反射"></a>1. 什么是反射</h2><p>在计算机科学中，反射（Reflection）是一种能力，允许程序在运行时检查、修改和使用其自身的结构和行为。这通常包括获取类型信息、访问对象的属性和方法，以及在运行时动态调用方法。<br>反射是许多现代编程语言中的一个重要特性，它为开发者提供了强大的灵活性和动态性。例如，在Java、C#和Go等语言中，反射机制允许开发者编写能够处理未知类型或动态生成代码的程序。</p><h2 id="2-Go语言反射"><a href="#2-Go语言反射" class="headerlink" title="2. Go语言反射"></a>2. Go语言反射</h2><p>Go语言的反射机制提供了一种在运行时检查和操作对象的能力。Go的反射API由<code>reflect</code>包提供，它允许开发者获取类型信息、访问和修改变量的值。<br>Go的反射机制与Java等语言的反射机制不同，它不支持运行时类型转换或动态调用方法。Go的反射主要用于类型断言和访问结构体的字段。</p><h2 id="3-reflect-TypeOf-的使用"><a href="#3-reflect-TypeOf-的使用" class="headerlink" title="3. reflect.TypeOf()的使用"></a>3. <code>reflect.TypeOf()</code>的使用</h2><p><code>reflect.TypeOf()</code>函数用于获取一个值的类型。这个函数返回一个<code>reflect.Type</code>类型，它包含了关于原始类型信息的详细信息。下面是一个使用<code>reflect.TypeOf()</code>的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-type">float64</span> = <span class="hljs-number">3.4</span><br>t := reflect.TypeOf(x)<br>fmt.Println(<span class="hljs-string">&quot;Type:&quot;</span>, t)<br>fmt.Println(<span class="hljs-string">&quot;Kind:&quot;</span>, t.Kind())<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码会输出变量<code>x</code>的类型和类型种类：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Type: <span class="hljs-type">float64</span><br>Kind: <span class="hljs-type">float64</span><br></code></pre></td></tr></table></figure><h2 id="4-reflect-ValueOf-的使用"><a href="#4-reflect-ValueOf-的使用" class="headerlink" title="4. reflect.ValueOf()的使用"></a>4. <code>reflect.ValueOf()</code>的使用</h2><p><code>reflect.ValueOf()</code>函数用于获取一个值的反射值。这个函数返回一个<code>reflect.Value</code>类型，它代表了原始值，并允许对它进行操作。以下是一个使用<code>reflect.ValueOf()</code>的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-type">float64</span> = <span class="hljs-number">3.4</span><br>v := reflect.ValueOf(x)<br>fmt.Println(<span class="hljs-string">&quot;Value:&quot;</span>, v)<br>fmt.Println(<span class="hljs-string">&quot;Type:&quot;</span>, v.Type())<br>fmt.Println(<span class="hljs-string">&quot;Kind is float64:&quot;</span>, v.Kind() == reflect.Float64)<br>fmt.Println(<span class="hljs-string">&quot;Value:&quot;</span>, v.Float())<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码展示了如何获取一个值的反射值，并使用这个反射值来访问原始值的类型和值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">Value: <span class="hljs-number">3.4</span><br>Type: <span class="hljs-type">float64</span>        <br>Kind is <span class="hljs-type">float64</span>: <span class="hljs-literal">true</span><br>Value: <span class="hljs-number">3.4</span> <br></code></pre></td></tr></table></figure><h2 id="5-struct反射使用"><a href="#5-struct反射使用" class="headerlink" title="5. struct反射使用"></a>5. struct反射使用</h2><p>在Go中，使用反射操作结构体是一种常见的需求。以下是一些基本的操作：</p><h3 id="5-1-获取字段数量"><a href="#5-1-获取字段数量" class="headerlink" title="5.1 获取字段数量"></a>5.1 获取字段数量</h3><p>使用<code>reflect.ValueOf()</code>获取结构体的反射值后，可以使用<code>NumField()</code>方法来获取结构体的字段数量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;Tom&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>v := reflect.ValueOf(p)<br>fmt.Println(<span class="hljs-string">&quot;Number of fields:&quot;</span>, v.NumField())<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Number of fields: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="5-2-获取字段值"><a href="#5-2-获取字段值" class="headerlink" title="5.2 获取字段值"></a>5.2 获取字段值</h3><p>使用<code>Field()</code>方法可以根据索引获取结构体中特定字段的反射值，使用<code>FieldByName()</code>方法可以根据字段名获取结构体中指定字段的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;Tom&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>v := reflect.ValueOf(p)<br>name := v.Field(<span class="hljs-number">0</span>)<br>age := v.FieldByName(<span class="hljs-string">&quot;Age&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;Name:&quot;</span>, name.Interface())<br>fmt.Println(<span class="hljs-string">&quot;Age:&quot;</span>, age.Interface())<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Name: Tom<br>Age: <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><h3 id="5-3-给字段赋值"><a href="#5-3-给字段赋值" class="headerlink" title="5.3 给字段赋值"></a>5.3 给字段赋值</h3><p>使用<code>SetField()</code>方法可以设置结构体中特定字段的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;Tom&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br><span class="hljs-comment">// 使用Elem()获取指针指向的值</span><br>v := reflect.ValueOf(&amp;p).Elem()<br>age := v.Field(<span class="hljs-number">1</span>)<br>age.SetInt(<span class="hljs-number">20</span>)<br>fmt.Println(<span class="hljs-string">&quot;age:&quot;</span>, p.Age)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">age: <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h3 id="5-4-检查字段可访问性"><a href="#5-4-检查字段可访问性" class="headerlink" title="5.4 检查字段可访问性"></a>5.4 检查字段可访问性</h3><p>在使用反射访问结构体字段时，需要检查字段是否可访问。如果字段是私有的（即字段名以大写字母开头），则在包外无法直接访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-comment">// 公共字段</span><br>age  <span class="hljs-type">int64</span>  <span class="hljs-comment">// 私有字段</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;Tom&quot;</span>, age: <span class="hljs-number">18</span>&#125;<br>v := reflect.ValueOf(p)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumField(); i++ &#123;<br>field := v.Type().Field(i)<br><span class="hljs-keyword">if</span> field.IsExported() &#123;<br>fmt.Println(<span class="hljs-string">&quot;Accessible field:&quot;</span>, field.Name)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Inaccessible field:&quot;</span>, field.Name)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Accessible field: Name<br>Inaccessible field: age<br></code></pre></td></tr></table></figure><h3 id="5-5-使用标签处理"><a href="#5-5-使用标签处理" class="headerlink" title="5.5 使用标签处理"></a>5.5 使用标签处理</h3><p>Go语言的结构体字段可以包含标签（Tag），这些标签可以被反射用来获取额外的信息。例如，标签可以用于JSON编码或数据库映射。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Age  <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;age&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;Tom&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>v := reflect.ValueOf(p)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumField(); i++ &#123;<br>field := v.Type().Field(i)<br>tag := field.Tag<br>fmt.Printf(<span class="hljs-string">&quot;Field: %s, Tag: %s\n&quot;</span>, field.Name, tag.Get(<span class="hljs-string">&quot;json&quot;</span>))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Field: Name, Tag: name<br>Field: Age, Tag: age<br></code></pre></td></tr></table></figure><h3 id="5-6-嵌套结构体的反射"><a href="#5-6-嵌套结构体的反射" class="headerlink" title="5.6 嵌套结构体的反射"></a>5.6 嵌套结构体的反射</h3><p>当结构体中包含其他结构体时，反射可以用来访问嵌套结构体的字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int64</span><br>Addr Address<br>&#125;<br><br><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;<br>Country <span class="hljs-type">string</span><br>City    <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;Tom&quot;</span>, Age: <span class="hljs-number">18</span>, Addr: Address&#123;<br>Country: <span class="hljs-string">&quot;China&quot;</span>,<br>City:    <span class="hljs-string">&quot;BeiJing&quot;</span>,<br>&#125;&#125;<br>v := reflect.ValueOf(p)<br>addr := v.FieldByName(<span class="hljs-string">&quot;Addr&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;Country:&quot;</span>, addr.Field(<span class="hljs-number">0</span>).Interface())<br>fmt.Println(<span class="hljs-string">&quot;City:&quot;</span>, addr.Field(<span class="hljs-number">1</span>).Interface())<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Country: China<br>City: BeiJing<br></code></pre></td></tr></table></figure><h3 id="5-7-动态创建结构体实例"><a href="#5-7-动态创建结构体实例" class="headerlink" title="5.7 动态创建结构体实例"></a>5.7 动态创建结构体实例</h3><p>反射还可以用于动态创建结构体实例，这在某些情况下非常有用，比如当结构体类型是从配置文件或数据库中动态确定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>rt := reflect.TypeOf(Person&#123;&#125;)<br>args := []reflect.Value&#123;reflect.ValueOf(<span class="hljs-string">&quot;Tom&quot;</span>), reflect.ValueOf(<span class="hljs-number">18</span>)&#125;<br>instance := reflect.New(rt).Elem()<br>instance.Field(<span class="hljs-number">0</span>).Set(args[<span class="hljs-number">0</span>])<br>instance.Field(<span class="hljs-number">1</span>).Set(args[<span class="hljs-number">1</span>])<br>fmt.Printf(<span class="hljs-string">&quot;Person: %+v\n&quot;</span>, instance.Interface())<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Person: &#123;Name:Tom Age:<span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-8-反射与接口"><a href="#5-8-反射与接口" class="headerlink" title="5.8 反射与接口"></a>5.8 反射与接口</h3><p>反射可以与接口一起使用来实现类型断言和类型检查。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = Person&#123;Name: <span class="hljs-string">&quot;Tom&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>rv := reflect.ValueOf(i)<br><span class="hljs-keyword">if</span> rv.Kind() == reflect.Struct &#123;<br>s := rv.Interface().(Person)<br>fmt.Println(<span class="hljs-string">&quot;Struct:&quot;</span>, s)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Struct: &#123;Tom <span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>反射是Go语言中一个强大的特性，它允许开发者在运行时检查和操作类型和值。虽然Go的反射机制与一些其他语言相比有所限制，但它仍然提供了足够的灵活性来处理许多常见的动态编程需求。通过使用<code>reflect.TypeOf()</code>和<code>reflect.ValueOf()</code>，开发者可以访问和修改变量的类型和值，以及操作结构体的字段。<br>反射的使用需要谨慎，因为它可能会使代码更难理解和维护。同事，在需要处理未知类型或需要高度灵活性的情况下，反射是一个不可或缺的工具。</p>]]></content>
    
    
    <summary type="html">在计算机科学中，反射（Reflection）是一种能力，允许程序在运行时检查、修改和使用其自身的结构和行为。</summary>
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Golang进阶" scheme="http://example.com/tags/Golang%E8%BF%9B%E9%98%B6/"/>
    
    <category term="反射" scheme="http://example.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Go语言单元测试详解</title>
    <link href="http://example.com/p/43abdc4.html"/>
    <id>http://example.com/p/43abdc4.html</id>
    <published>2024-08-09T11:58:20.000Z</published>
    <updated>2024-10-15T09:27:38.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h1><h2 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h2><p>在Go语言中，使用单元测试的主要工具命令就是<code>go test</code>，不需要额外其他工具或库来进行单元测试，在使用go test命令时，系统会自动根据一定的约定将当前包内的所有以_test.go为后缀的源代码文件作为测试文件，同时测试文件中所有以Test为前缀的函数都将被作为测试函数全部执行。</p><h2 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h2><p>基于上面的描述，在写单元测试代码时，需要遵循一定的规范：</p><ol><li>通常单元测试文件和源代码程序文件放在一起，不使用额外的test包；</li><li>单元测试文件必须以_test.go为后缀；</li><li>单元测试函数必须以Test为前缀（基准测试函数以Benchmark为前缀）；</li><li>单元测试函数参数必须为t *testing.T（基准测试函数为b *testing.B）；</li></ol><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>根据上面的规则，在使用单元测试时，必须导入testing包，函数名称必须以Test为前缀，后缀必须以大写字母开头，通常后缀为对应需要测试的函数名称，以下示例为测试函数的基本格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Add函数对应单元测试函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAdd</span><span class="hljs-params">(t *testing.T)</span></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>现在，我们写一个简单的计算绝对值的函数Abs，然后通过这个函数来看单元测试的基本使用函数，首先定义一个包，在包里面新建源代码文件和测试文件，目录结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">calc<br> --calc.<span class="hljs-keyword">go</span><br> --calc_test.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>在calc.go源代码文件中写一个简单的函数用于计算绝对值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Abs</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> i<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> -i<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在calc_test.go测试文件中写一个简单的单元测试函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>got := Abs(<span class="hljs-number">-1</span>)<br><span class="hljs-keyword">if</span> got != <span class="hljs-number">1</span> &#123;<br>t.Errorf(<span class="hljs-string">&quot;excepted: %d, got: %d&quot;</span>, <span class="hljs-number">1</span>, got)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中调用Abs函数，并传入参数-1，使用got接收返回值，如果返回值不是我们期望的1，则可以使用t.Errorf输出错误信息。<br>然后使用go test命令运行单元测试：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic">PS C:\Users\lee\GolandProjects\test\test&gt; go test<br>PASS<br>ok      test/calc       <span class="hljs-number">0.200</span>s<br></code></pre></td></tr></table></figure><p>可以看到输出了PASS表示测试通过，同时还可以在命令后面加上-v查看更详细输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic">PS C:\Users\lee\GolandProjects\test\calc&gt; go test -v<br>=== <span class="hljs-keyword">RUN</span>   TestAbs<br>--- PASS: TestAbs (<span class="hljs-number">0.00</span>s)<br>PASS<br>ok      test/calc       <span class="hljs-number">0.142</span>s<br></code></pre></td></tr></table></figure><p>记得我们上面说过的，如果使用go test命令系统会自动根据一定的约定将当前包内的所有以_test.go为后缀的源代码文件作为测试文件，同时测试文件中所有以Test为前缀的函数都将被作为测试函数全部执行。但如果我们仅仅只需要跑其中一个测试函数怎么办呢，可以在命令后面加上-run参数指定函数名称，即可运行指定的测试函数。<br>首先在源代码文件和测试文件中分别加入一个功能函数和一个测试函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> i + j<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAdd</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>got := Add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span> got != <span class="hljs-number">3</span> &#123;<br>t.Errorf(<span class="hljs-string">&quot;excepted: %d, got: %d&quot;</span>, <span class="hljs-number">1</span>, got)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候如果直接执行go test就会将两个测试函数都执行，通过指定的方式只执行其中一个测试函数。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic">PS C:\Users\lee\GolandProjects\test\calc&gt; go test -v -<span class="hljs-keyword">run</span>=Add<br>=== <span class="hljs-keyword">RUN</span>   TestAdd<br>--- PASS: TestAdd (<span class="hljs-number">0.00</span>s)<br>PASS<br>ok      test/calc       <span class="hljs-number">0.151</span>s<br></code></pre></td></tr></table></figure><p>在通过-run命令指定函数的时候可以写功能函数的名称，也可以写测试函数的名称，两者都是一样的效果。</p><h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><p>go test命令还有一个参数是用来专门看单元测试对于功能代码的覆盖情况，命令为go test -cover，使用该命令可以清晰的看到单元测试的覆盖率。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic">PS C:\Users\lee\GolandProjects\test\calc&gt; go test -cover<br>PASS<br>coverage: <span class="hljs-number">75.0</span>% of statements<br>ok      test/calc       <span class="hljs-number">0.188</span>s<br></code></pre></td></tr></table></figure><p>使用该命令针对我们上面的单元测试进行测试，能够看到单元测试的覆盖率为75%，这表示在功能性代码里面还有一部分的情况没有测试到，这样的话我们可以使用-coverprofile参数将测试的覆盖率保存到文件中，然后在文件中查看到底是哪部分的内容没有被测试到的。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic">C:\Users\lee\GolandProjects\test\calc&gt;go test -cover -coverprofile=cover.<span class="hljs-keyword">out</span><br>PASS<br>coverage: <span class="hljs-number">75.0</span>% of statements<br>ok      test/calc       <span class="hljs-number">0.184</span>s<br></code></pre></td></tr></table></figure><p>使用该命令之后就会在当前目录下生成一个cover.out文件（注意：使用该命令需要确保当前命令行有管理员权限，否则会导致创建文件失败），用来保存测试覆盖率相关的记录，但是我们打开当前文件发现里面的内容并不能看出是哪个地方没有被覆盖到，这时候我们可以使用go tool命令来将记录文件生成一个HTML格式的报告。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic">go tool cover -html=cover.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>直接运行这个命令就会生成HTML的报告，并直接在浏览器中打开，报告如下：</p><img src="/p/43abdc4/1.png" class="" title="s"><p>通过报告就能看到是Abs函数中关于负数部分的分支没有被覆盖到，这时候如果我们在TestAbs函数中增加一个测试用例测试负数的情况，再跑覆盖率就会达到100%的覆盖率。</p><h2 id="测试组"><a href="#测试组" class="headerlink" title="测试组"></a>测试组</h2><p>正如上面所讲，单元测试需要尽可能多的覆盖功能代码中的不同情况，这个时候可能就需要在测试代码中写上很多的测试用例，但是一个个去写测试用例肯定不是一个明确的做法，所以这个时候就需要使用测试组，测试组简单理解就是将多个测试用例汇聚到一起，然后使用循环的方式来一个个测试，如果需要新增或删除测试用例可以直接在数组中修改，不需要改动代码。测试组的使用方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">// 定义测试用例需要使用到的结构体，包含输入以及期望的结果</span><br>    <span class="hljs-keyword">type</span> test <span class="hljs-keyword">struct</span> &#123;<br>        input <span class="hljs-type">int</span><br>        want  <span class="hljs-type">int</span><br>    &#125;<br>    <span class="hljs-comment">// 构建测试用例</span><br>    tests := []test&#123;<br>        &#123;input: <span class="hljs-number">1</span>, want: <span class="hljs-number">1</span>&#125;,<br>        &#123;input: <span class="hljs-number">2</span>, want: <span class="hljs-number">2</span>&#125;,<br>        &#123;input: <span class="hljs-number">0</span>, want: <span class="hljs-number">0</span>&#125;,<br>        &#123;input: <span class="hljs-number">-1</span>, want: <span class="hljs-number">1</span>&#125;,<br>    &#125;<br>    <span class="hljs-comment">// 循环测试组对每个测试用例进行测试</span><br>    <span class="hljs-keyword">for</span> _, tc := <span class="hljs-keyword">range</span> tests &#123;<br>        got := Abs(tc.input)<br>        <span class="hljs-keyword">if</span> got != tc.want &#123;<br>            t.Errorf(<span class="hljs-string">&quot;want: %d, got: %d&quot;</span>, tc.want, got)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用命令进行测试：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic">PS C:\Users\lee\GolandProjects\test\calc&gt; go test -v -<span class="hljs-keyword">run</span>=<span class="hljs-keyword">Abs</span><br>=== <span class="hljs-keyword">RUN</span>   TestAbs<br>--- PASS: TestAbs (<span class="hljs-number">0.00</span>s)<br>PASS<br>ok      test/calc       <span class="hljs-number">0.163</span>s<br></code></pre></td></tr></table></figure><p>通过测试组可以将测试多个测试用例聚合到一起进行测试，方便测试用例的新增和删除，这样不仅代码美观还提高了代码的扩展性。</p><h2 id="子测试"><a href="#子测试" class="headerlink" title="子测试"></a>子测试</h2><p>通过上面测试组的方法，能够很容易的将多个测试用例汇聚到一起，但同时也带来了一个问题，那就是当测试用例过多的时候，如果其中某个测试用例发生错误，不太容易能够看出是哪个测试用例的问题，这时候我们就需要给所有的测试用例一个特定的标签或名字，代码修改如下，并将其中的某一个用例的期望值改成错误的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">// 定义测试用例需要使用到的结构体，包含输入以及期望的结果</span><br><span class="hljs-keyword">type</span> test <span class="hljs-keyword">struct</span> &#123;<br>input <span class="hljs-type">int</span><br>want  <span class="hljs-type">int</span><br>&#125;<br>    <span class="hljs-comment">// 构建测试用例</span><br>tests := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]test&#123;<br><span class="hljs-string">&quot;No1&quot;</span>: &#123;input: <span class="hljs-number">1</span>, want: <span class="hljs-number">1</span>&#125;,<br><span class="hljs-string">&quot;No2&quot;</span>: &#123;input: <span class="hljs-number">2</span>, want: <span class="hljs-number">3</span>&#125;,<br><span class="hljs-string">&quot;No3&quot;</span>: &#123;input: <span class="hljs-number">0</span>, want: <span class="hljs-number">0</span>&#125;,<br><span class="hljs-string">&quot;No4&quot;</span>: &#123;input: <span class="hljs-number">-1</span>, want: <span class="hljs-number">1</span>&#125;,<br>&#125;<br>    <span class="hljs-comment">// 循环测试组对每个测试用例进行测试</span><br><span class="hljs-keyword">for</span> name, tc := <span class="hljs-keyword">range</span> tests &#123;<br>got := Abs(tc.input)<br><span class="hljs-keyword">if</span> got != tc.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;name: %s, want: %d, got: %d&quot;</span>, name, tc.want, got)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后开始测试</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic">PS C:\Users\lee\GolandProjects\test\calc&gt; go test -v -<span class="hljs-keyword">run</span>=<span class="hljs-keyword">Abs</span><br>=== <span class="hljs-keyword">RUN</span>   TestAbs<br>  calc_test.go:<span class="hljs-number">35</span>: <span class="hljs-keyword">name</span>: No2, want: <span class="hljs-number">3</span>, got: <span class="hljs-number">2</span><br>--- FAIL: TestAbs (<span class="hljs-number">0.00</span>s)<br>FAIL<br>exit status <span class="hljs-number">1</span><br>FAIL    test/calc       <span class="hljs-number">0.196</span>s<br></code></pre></td></tr></table></figure><p>通过上面的输出就能够看到是名称为No2的测试用例没有通过，使用上面的方法虽然可以简单的看到出错的测试用例，但是还不够明显，这时候可以使用单元测试中的子测试，通过子测试方法能够更清晰明了的看到每一个用例的通过情况，修改代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">// 定义测试用例需要使用到的结构体，包含输入以及期望的结果</span><br><span class="hljs-keyword">type</span> test <span class="hljs-keyword">struct</span> &#123;<br>input <span class="hljs-type">int</span><br>want  <span class="hljs-type">int</span><br>&#125;<br>    <span class="hljs-comment">// 构建测试用例</span><br>tests := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]test&#123;<br><span class="hljs-string">&quot;No1&quot;</span>: &#123;input: <span class="hljs-number">1</span>, want: <span class="hljs-number">1</span>&#125;,<br><span class="hljs-string">&quot;No2&quot;</span>: &#123;input: <span class="hljs-number">2</span>, want: <span class="hljs-number">3</span>&#125;,<br><span class="hljs-string">&quot;No3&quot;</span>: &#123;input: <span class="hljs-number">0</span>, want: <span class="hljs-number">0</span>&#125;,<br><span class="hljs-string">&quot;No4&quot;</span>: &#123;input: <span class="hljs-number">-1</span>, want: <span class="hljs-number">1</span>&#125;,<br>&#125;<br>    <span class="hljs-comment">// 循环测试组对每个测试用例进行测试</span><br><span class="hljs-keyword">for</span> name, tc := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>got := Abs(tc.input)<br><span class="hljs-keyword">if</span> got != tc.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;want: %d, got: %d&quot;</span>, tc.want, got)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试函数的参数t可以调用Run方法，该方法接收一个name参数和一个函数类型的参数，然后再次开始测试</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs basic">PS C:\Users\lee\GolandProjects\test\calc&gt; go test -v -<span class="hljs-keyword">run</span>=<span class="hljs-keyword">Abs</span><br>=== <span class="hljs-keyword">RUN</span>   TestAbs<br>=== <span class="hljs-keyword">RUN</span>   TestAbs/No3<br>=== <span class="hljs-keyword">RUN</span>   TestAbs/No4<br>=== <span class="hljs-keyword">RUN</span>   TestAbs/No1<br>=== <span class="hljs-keyword">RUN</span>   TestAbs/No2<br>calc_test.go:<span class="hljs-number">43</span>: want: <span class="hljs-number">3</span>, got: <span class="hljs-number">2</span><br>--- FAIL: TestAbs (<span class="hljs-number">0.00</span>s)<br>  --- PASS: TestAbs/No3 (<span class="hljs-number">0.00</span>s)<br>  --- PASS: TestAbs/No4 (<span class="hljs-number">0.00</span>s)<br>  --- PASS: TestAbs/No1 (<span class="hljs-number">0.00</span>s)<br>  --- FAIL: TestAbs/No2 (<span class="hljs-number">0.00</span>s)<br>FAIL<br>exit status <span class="hljs-number">1</span><br>FAIL    test/calc       <span class="hljs-number">0.182</span>s<br></code></pre></td></tr></table></figure><p>通过上面的输出能够清晰的看到通过的测试用例以及没有通过的测试用例，相比较于第一种的方式，输出更加清晰明了，这就是使用子测试的好处。</p><h1 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h1><p>基准测试，也就是<code>BenchmarkTest</code>，基准测试是用来测试代码性能的的一种方法，使用基准测试时，测试函数必须以<code>Benchmark</code>开头，后面跟具体需要测试的函数的名称，基本格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Add函数对应的基准测试函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkAdd</span><span class="hljs-params">(b *testing.B)</span></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>基准测试函数中的参数是<code>b *testing.B</code>，基准测试时函数必须要执行<code>b.N</code>次，只有这样测试才能具有参考性和一定的准确性。<code>b.N</code>这个值并不是固定的，而是根据情况变化，从<code>1</code>开始，如果当前测试函数能够在<code>1</code>秒内执行完毕，则会将<code>b.N</code>的值增加到<code>2</code>，如果测试函数同样在<code>1</code>秒内执行完毕，则会继续增加<code>b.N</code>的值，<code>b.N</code>的递增序列为<code>1,2,3,5,10,20,30,50,100</code>。</p><h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><p>现在我们先写一个计算斐波拉契数列的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Fib 递归函数计算斐波拉契数列的第 x 个数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fib</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> x &lt;= <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> x<br>&#125;<br><span class="hljs-keyword">return</span> Fib(x<span class="hljs-number">-1</span>) + Fib(x<span class="hljs-number">-2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在对应的测试文件中写上针对Fib函数的基准测试函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFib</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>Fib(<span class="hljs-number">10</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在功能函数和基准测试函数都准备完毕之后我们可以使用<code>go test</code>命令来执行对应的基准测试，使用该命令不能直接运行基准测试，需要在参数后面指定<code>-bench</code>参数并指定响应的函数名称。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">PS C:\Users\lee\GolandProjects\test\calc&gt; <span class="hljs-keyword">go</span> test -bench=Fib<br>goos: windows<br>goarch: amd64<br>pkg: test/calc<br>cpu: Intel(R) Core(TM) i7<span class="hljs-number">-9700</span> CPU @ <span class="hljs-number">3.00</span>GHz<br>BenchmarkFib<span class="hljs-number">-8</span>           <span class="hljs-number">4861580</span>               <span class="hljs-number">235.1</span> ns/op<br>PASS<br>ok      test/calc       <span class="hljs-number">1.567</span>s<br></code></pre></td></tr></table></figure><p>上面的输出中，上面都是一些系统相关信息，下面<code>BenchmarkFib-8</code>后面的数字表示的是<code>GOMAXPROCS</code>，默认等于CPU的核数，后面的<code>4861580</code>和<code>235.1 ns/op</code>表示当前测试用例执行的<code>4861580</code>次，平均花费时间为<code>235.1 ns</code>，总耗时为<code>1.567s</code>。<br>在使用的时候还可以通过其他参数来获取更多的测试数据，用来提升测试的准确率和可参考性。<br>使用<code>-benchmem</code>参数来获取内存分配的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">PS C:\Users\lee\GolandProjects\test\calc&gt; <span class="hljs-keyword">go</span> test -bench=Fib -benchmem<br>goos: windows<br>goarch: amd64<br>pkg: test/calc<br>cpu: Intel(R) Core(TM) i7<span class="hljs-number">-9700</span> CPU @ <span class="hljs-number">3.00</span>GHz<br>BenchmarkFib<span class="hljs-number">-8</span>           <span class="hljs-number">4749666</span>               <span class="hljs-number">251.0</span> ns/op             <span class="hljs-number">0</span> B/op          <span class="hljs-number">0</span> allocs/op<br>PASS<br>ok      test/calc       <span class="hljs-number">1.609</span>s<br></code></pre></td></tr></table></figure><p>在耗时的后面新增了<code>0 B/op</code>和<code>0 allocs/op</code>，其中<code>0 B/op</code>表示每次运行测试分配了0B的内存，<code>0 allocs/op</code>表示每次运行测试进行了0次的内存分配，因为我们的功能函数没用到额外的内存，所以这两个值都是0，大家可以自己尝试其他方法来看看这个值的变化。<br>使用<code>-benchtime</code>参数指定测试的基准时间或次数，在前面我们说过测试用例会执行<code>b.N</code>次，这个数量是动态变化的，只要运行测试用例的时间没有超过<code>1</code>秒就会递增这个值。现在可以使用<code>-benchtime</code>参数指定这个基准时间，如果修改为<code>5</code>，可以使用<code>-benchtime=5s</code>，则表示执行时间不超过<code>5</code>秒，就会递增<code>b.N</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">PS C:\Users\lee\GolandProjects\test\calc&gt; <span class="hljs-keyword">go</span> test -bench=Fib -benchtime=<span class="hljs-number">5</span>s<br>goos: windows<br>goarch: amd64<br>pkg: test/calc<br>cpu: Intel(R) Core(TM) i7<span class="hljs-number">-9700</span> CPU @ <span class="hljs-number">3.00</span>GHz<br>BenchmarkFib<span class="hljs-number">-8</span>          <span class="hljs-number">23184202</span>               <span class="hljs-number">235.6</span> ns/op<br>PASS<br>ok      test/calc       <span class="hljs-number">5.859</span>s<br></code></pre></td></tr></table></figure><p>通过上面的输出可以看到，一共运行了<code>23184202</code>次，平均每次耗时<code>235.6 ns</code>，总耗时<code>5.859s</code>。因为通过<code>-benchtime</code>指定了基准时间为<code>5</code>秒，所以总运行次数大概是之前的<code>5</code>倍。<br><code>-benchtime</code>除了指定时间之外，还可以用来指定具体的次数，假设指定执行100次，可以使用<code>-benchtime=100x</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">PS C:\Users\lee\GolandProjects\test\calc&gt; <span class="hljs-keyword">go</span> test -bench=Fib -benchtime=<span class="hljs-number">100</span>x<br>goos: windows<br>goarch: amd64<br>pkg: test/calc<br>cpu: Intel(R) Core(TM) i7<span class="hljs-number">-9700</span> CPU @ <span class="hljs-number">3.00</span>GHz<br>BenchmarkFib<span class="hljs-number">-8</span>               <span class="hljs-number">100</span>               <span class="hljs-number">487.0</span> ns/op<br>PASS<br>ok      test/calc       <span class="hljs-number">0.167</span>s<br></code></pre></td></tr></table></figure><p>上面可以看到通过<code>-benchtime</code>指定次数后，一共调用了<code>Fib</code>函数<code>100</code>次，总耗时<code>0.167s</code>。<br><code>-count</code>参数可以用来指定测试的轮数，比如指定执行3轮。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">PS C:\Users\lee\GolandProjects\test\calc&gt; <span class="hljs-keyword">go</span> test -bench=Fib -count=<span class="hljs-number">3</span>       <br>goos: windows<br>goarch: amd64<br>pkg: test/calc<br>cpu: Intel(R) Core(TM) i7<span class="hljs-number">-9700</span> CPU @ <span class="hljs-number">3.00</span>GHz<br>BenchmarkFib<span class="hljs-number">-8</span>           <span class="hljs-number">4641591</span>               <span class="hljs-number">261.0</span> ns/op<br>BenchmarkFib<span class="hljs-number">-8</span>           <span class="hljs-number">5031808</span>               <span class="hljs-number">238.0</span> ns/op<br>BenchmarkFib<span class="hljs-number">-8</span>           <span class="hljs-number">5103565</span>               <span class="hljs-number">245.1</span> ns/op<br></code></pre></td></tr></table></figure><h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>在基准测试中，某些功能函数在不同的输入时，相对应的性能也会有所差别，在前面的所有测试中，我们传递的参数都是10，也就是每次都计算的是斐波拉契数列的第10个，如果我们需要测试一个函数在不同的输入下的性能差异，或者是测试两个函数在相同输入下的性能差异，就会使用到性能比较的测试方法，在比较性能的时候就需要使用到一个带参数的测试函数，再使用其他的Benchmark函数传入不同的值来调用，用以测试不同输入的性能差别。<br>我们将上面的测试代码修改如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">benchmarkFib</span><span class="hljs-params">(b *testing.B, n <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>Fib(n)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFib2</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkFib(b, <span class="hljs-number">2</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFib10</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkFib(b, <span class="hljs-number">10</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFib20</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkFib(b, <span class="hljs-number">20</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFib30</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkFib(b, <span class="hljs-number">30</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码中写了一个带有参数的辅助函数benchmarkFib，可以传入参数，并且构造了4个测试用例，分别传入不同的参数，执行上面的测试用例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">PS C:\Users\lee\GolandProjects\test\calc&gt; <span class="hljs-keyword">go</span> test -bench=Fib<br>goos: windows<br>goarch: amd64<br>pkg: test/calc<br>cpu: Intel(R) Core(TM) i7<span class="hljs-number">-9700</span> CPU @ <span class="hljs-number">3.00</span>GHz<br>BenchmarkFib2<span class="hljs-number">-8</span>         <span class="hljs-number">304879520</span>                <span class="hljs-number">3.793</span> ns/op<br>BenchmarkFib10<span class="hljs-number">-8</span>         <span class="hljs-number">5249786</span>               <span class="hljs-number">232.8</span> ns/op<br>BenchmarkFib20<span class="hljs-number">-8</span>           <span class="hljs-number">41760</span>             <span class="hljs-number">28409</span> ns/op<br>BenchmarkFib30<span class="hljs-number">-8</span>             <span class="hljs-number">345</span>           <span class="hljs-number">3571588</span> ns/op<br>PASS<br>ok      test/calc       <span class="hljs-number">6.245</span>s<br></code></pre></td></tr></table></figure><p>可以看到，在不同的输入下，函数的执行次数和平均执行时间都有不小的差距，当计算第<code>30</code>个数的时候一共才执行了<code>345</code>次，而每次的平均执行时间为<code>3571588 ns</code>。</p><h2 id="重置时间"><a href="#重置时间" class="headerlink" title="重置时间"></a>重置时间</h2><p>在进行基准测试的时候，通常都是用来测试函数的性能，我们上面的函数都是简单的一些示例，但是在日常的工作中，我们测试之前可能需要有一些准备工作，例如测试前读取文件，这样的话在测试的时候就会将读取文件的耗时也计算到测试报告里面去，这个时候我们可以使用到ResetTimer来重置时间，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFib</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-comment">// sleep 3秒，模拟测试前的准备工作</span><br>time.Sleep(time.Second * <span class="hljs-number">3</span>)<br><span class="hljs-comment">// 重置定时器</span><br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>Fib(<span class="hljs-number">10</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码中调用了b.ResetTimer()方法，这样就表示重置定时器，意味着这行代码之前的所有代码的耗时都不会被计算到测试中，这样能够确保代码测试的准确性。</p>]]></content>
    
    
    <summary type="html">Go语言单元测试详解</summary>
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
    <category term="单元测试" scheme="http://example.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
